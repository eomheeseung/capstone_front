{"ast":null,"code":"var _classCallCheck = require(\"C:/Users/paete/Prototype/nftmusicProtoCopy/client/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\nvar _createClass = require(\"C:/Users/paete/Prototype/nftmusicProtoCopy/client/node_modules/@babel/runtime/helpers/createClass.js\").default;\nvar _regeneratorRuntime = require(\"C:/Users/paete/Prototype/nftmusicProtoCopy/client/node_modules/@babel/runtime/helpers/regeneratorRuntime.js\").default;\nvar _asyncToGenerator = require(\"C:/Users/paete/Prototype/nftmusicProtoCopy/client/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\nvar cacheUtils = require('./cache-utils.js');\nvar createAsyncMiddleware = require('json-rpc-engine/src/createAsyncMiddleware');\n// `<nil>` comes from https://github.com/ethereum/go-ethereum/issues/16925\nvar emptyValues = [undefined, null, \"<nil>\"];\nmodule.exports = createBlockCacheMiddleware;\nfunction createBlockCacheMiddleware() {\n  var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  // validate options\n  var blockTracker = opts.blockTracker;\n  if (!blockTracker) throw new Error('createBlockCacheMiddleware - No BlockTracker specified');\n\n  // create caching strategies\n  var blockCache = new BlockCacheStrategy();\n  var strategies = {\n    perma: blockCache,\n    block: blockCache,\n    fork: blockCache\n  };\n  return createAsyncMiddleware( /*#__PURE__*/function () {\n    var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(req, res, next) {\n      var type, strategy, blockTag, requestedBlockNumber, latestBlockNumber, cacheResult;\n      return _regeneratorRuntime().wrap(function _callee$(_context) {\n        while (1) switch (_context.prev = _context.next) {\n          case 0:\n            if (!req.skipCache) {\n              _context.next = 2;\n              break;\n            }\n            return _context.abrupt(\"return\", next());\n          case 2:\n            // check type and matching strategy\n            type = cacheUtils.cacheTypeForPayload(req);\n            strategy = strategies[type]; // If there's no strategy in place, pass it down the chain.\n            if (strategy) {\n              _context.next = 6;\n              break;\n            }\n            return _context.abrupt(\"return\", next());\n          case 6:\n            if (strategy.canCacheRequest(req)) {\n              _context.next = 8;\n              break;\n            }\n            return _context.abrupt(\"return\", next());\n          case 8:\n            // get block reference (number or keyword)\n            blockTag = cacheUtils.blockTagForPayload(req);\n            if (!blockTag) blockTag = 'latest';\n\n            // get exact block number\n            if (!(blockTag === 'earliest')) {\n              _context.next = 14;\n              break;\n            }\n            // this just exists for symmetry with \"latest\"\n            requestedBlockNumber = '0x00';\n            _context.next = 23;\n            break;\n          case 14:\n            if (!(blockTag === 'latest')) {\n              _context.next = 22;\n              break;\n            }\n            _context.next = 17;\n            return blockTracker.getLatestBlock();\n          case 17:\n            latestBlockNumber = _context.sent;\n            // clear all cache before latest block\n            blockCache.clearBefore(latestBlockNumber);\n            requestedBlockNumber = latestBlockNumber;\n            _context.next = 23;\n            break;\n          case 22:\n            // We have a hex number\n            requestedBlockNumber = blockTag;\n          case 23:\n            _context.next = 25;\n            return strategy.get(req, requestedBlockNumber);\n          case 25:\n            cacheResult = _context.sent;\n            if (!(cacheResult === undefined)) {\n              _context.next = 33;\n              break;\n            }\n            _context.next = 29;\n            return next();\n          case 29:\n            _context.next = 31;\n            return strategy.set(req, requestedBlockNumber, res.result);\n          case 31:\n            _context.next = 34;\n            break;\n          case 33:\n            // fill in result from cache\n            res.result = cacheResult;\n          case 34:\n          case \"end\":\n            return _context.stop();\n        }\n      }, _callee);\n    }));\n    return function (_x, _x2, _x3) {\n      return _ref.apply(this, arguments);\n    };\n  }());\n}\n\n//\n// Cache Strategies\n//\nvar BlockCacheStrategy = /*#__PURE__*/function () {\n  \"use strict\";\n\n  function BlockCacheStrategy() {\n    _classCallCheck(this, BlockCacheStrategy);\n    this.cache = {};\n  }\n  _createClass(BlockCacheStrategy, [{\n    key: \"getBlockCacheForPayload\",\n    value: function getBlockCacheForPayload(payload, blockNumberHex) {\n      var blockNumber = Number.parseInt(blockNumberHex, 16);\n      var blockCache = this.cache[blockNumber];\n      // create new cache if necesary\n      if (!blockCache) {\n        var newCache = {};\n        this.cache[blockNumber] = newCache;\n        blockCache = newCache;\n      }\n      return blockCache;\n    }\n  }, {\n    key: \"get\",\n    value: function () {\n      var _get = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(payload, requestedBlockNumber) {\n        var blockCache, identifier, cached;\n        return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n          while (1) switch (_context2.prev = _context2.next) {\n            case 0:\n              // lookup block cache\n              blockCache = this.getBlockCacheForPayload(payload, requestedBlockNumber);\n              if (blockCache) {\n                _context2.next = 3;\n                break;\n              }\n              return _context2.abrupt(\"return\");\n            case 3:\n              // lookup payload in block cache\n              identifier = cacheUtils.cacheIdentifierForPayload(payload, true);\n              cached = blockCache[identifier]; // may be undefined\n              return _context2.abrupt(\"return\", cached);\n            case 6:\n            case \"end\":\n              return _context2.stop();\n          }\n        }, _callee2, this);\n      }));\n      function get(_x4, _x5) {\n        return _get.apply(this, arguments);\n      }\n      return get;\n    }()\n  }, {\n    key: \"set\",\n    value: function () {\n      var _set = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(payload, requestedBlockNumber, result) {\n        var canCache, blockCache, identifier;\n        return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n          while (1) switch (_context3.prev = _context3.next) {\n            case 0:\n              // check if we can cached this result\n              canCache = this.canCacheResult(payload, result);\n              if (canCache) {\n                _context3.next = 3;\n                break;\n              }\n              return _context3.abrupt(\"return\");\n            case 3:\n              // set the value in the cache\n              blockCache = this.getBlockCacheForPayload(payload, requestedBlockNumber);\n              identifier = cacheUtils.cacheIdentifierForPayload(payload, true);\n              blockCache[identifier] = result;\n            case 6:\n            case \"end\":\n              return _context3.stop();\n          }\n        }, _callee3, this);\n      }));\n      function set(_x6, _x7, _x8) {\n        return _set.apply(this, arguments);\n      }\n      return set;\n    }()\n  }, {\n    key: \"canCacheRequest\",\n    value: function canCacheRequest(payload) {\n      // check request method\n      if (!cacheUtils.canCache(payload)) {\n        return false;\n      }\n      // check blockTag\n      var blockTag = cacheUtils.blockTagForPayload(payload);\n      if (blockTag === 'pending') {\n        return false;\n      }\n      // can be cached\n      return true;\n    }\n  }, {\n    key: \"canCacheResult\",\n    value: function canCacheResult(payload, result) {\n      // never cache empty values (e.g. undefined)\n      if (emptyValues.includes(result)) return;\n      // check if transactions have block reference before caching\n      if (['eth_getTransactionByHash', 'eth_getTransactionReceipt'].includes(payload.method)) {\n        if (!result || !result.blockHash || result.blockHash === '0x0000000000000000000000000000000000000000000000000000000000000000') {\n          return false;\n        }\n      }\n      // otherwise true\n      return true;\n    }\n\n    // removes all block caches with block number lower than `oldBlockHex`\n  }, {\n    key: \"clearBefore\",\n    value: function clearBefore(oldBlockHex) {\n      var self = this;\n      var oldBlockNumber = Number.parseInt(oldBlockHex, 16);\n      // clear old caches\n      Object.keys(self.cache).map(Number).filter(function (num) {\n        return num < oldBlockNumber;\n      }).forEach(function (num) {\n        return delete self.cache[num];\n      });\n    }\n  }]);\n  return BlockCacheStrategy;\n}();","map":{"version":3,"names":["cacheUtils","require","createAsyncMiddleware","emptyValues","undefined","module","exports","createBlockCacheMiddleware","opts","blockTracker","Error","blockCache","BlockCacheStrategy","strategies","perma","block","fork","req","res","next","skipCache","type","cacheTypeForPayload","strategy","canCacheRequest","blockTag","blockTagForPayload","requestedBlockNumber","getLatestBlock","latestBlockNumber","clearBefore","get","cacheResult","set","result","cache","payload","blockNumberHex","blockNumber","Number","parseInt","newCache","getBlockCacheForPayload","identifier","cacheIdentifierForPayload","cached","canCache","canCacheResult","includes","method","blockHash","oldBlockHex","self","oldBlockNumber","Object","keys","map","filter","num","forEach"],"sources":["C:/Users/paete/Prototype/nftmusicProtoCopy/client/node_modules/eth-json-rpc-middleware/block-cache.js"],"sourcesContent":["const cacheUtils = require('./cache-utils.js')\nconst createAsyncMiddleware = require('json-rpc-engine/src/createAsyncMiddleware')\n// `<nil>` comes from https://github.com/ethereum/go-ethereum/issues/16925\nconst emptyValues = [undefined, null, '\\u003cnil\\u003e']\n\nmodule.exports = createBlockCacheMiddleware\n\n\nfunction createBlockCacheMiddleware(opts = {}) {\n  // validate options\n  const { blockTracker } = opts\n  if (!blockTracker) throw new Error('createBlockCacheMiddleware - No BlockTracker specified')\n\n  // create caching strategies\n  const blockCache = new BlockCacheStrategy()\n  const strategies = {\n    perma: blockCache,\n    block: blockCache,\n    fork: blockCache,\n  }\n\n  return createAsyncMiddleware(async (req, res, next) => {\n    // allow cach to be skipped if so specified\n    if (req.skipCache) {\n      return next()\n    }\n    // check type and matching strategy\n    const type = cacheUtils.cacheTypeForPayload(req)\n    const strategy = strategies[type]\n    // If there's no strategy in place, pass it down the chain.\n    if (!strategy) {\n      return next()\n    }\n    // If the strategy can't cache this request, ignore it.\n    if (!strategy.canCacheRequest(req)) {\n      return next()\n    }\n\n    // get block reference (number or keyword)\n    let blockTag = cacheUtils.blockTagForPayload(req)\n    if (!blockTag) blockTag = 'latest'\n\n    // get exact block number\n    let requestedBlockNumber\n    if (blockTag === 'earliest') {\n      // this just exists for symmetry with \"latest\"\n      requestedBlockNumber = '0x00'\n    } else if (blockTag === 'latest') {\n      // fetch latest block number\n      const latestBlockNumber = await blockTracker.getLatestBlock()\n      // clear all cache before latest block\n      blockCache.clearBefore(latestBlockNumber)\n      requestedBlockNumber = latestBlockNumber\n    } else {\n      // We have a hex number\n      requestedBlockNumber = blockTag\n    }\n\n    // end on a hit, continue on a miss\n    const cacheResult = await strategy.get(req, requestedBlockNumber)\n    if (cacheResult === undefined) {\n      // cache miss\n      // wait for other middleware to handle request\n      await next()\n      // add result to cache\n      await strategy.set(req, requestedBlockNumber, res.result)\n    } else {\n      // fill in result from cache\n      res.result = cacheResult\n    }\n  })\n}\n\n\n//\n// Cache Strategies\n//\n\nclass BlockCacheStrategy {\n  \n  constructor () {\n    this.cache = {}\n  }\n\n  getBlockCacheForPayload (payload, blockNumberHex) {\n    const blockNumber = Number.parseInt(blockNumberHex, 16)\n    let blockCache = this.cache[blockNumber]\n    // create new cache if necesary\n    if (!blockCache) {\n      const newCache = {}\n      this.cache[blockNumber] = newCache\n      blockCache = newCache\n    }\n    return blockCache\n  }\n\n  async get (payload, requestedBlockNumber) {\n    // lookup block cache\n    const blockCache = this.getBlockCacheForPayload(payload, requestedBlockNumber)\n    if (!blockCache) return\n    // lookup payload in block cache\n    const identifier = cacheUtils.cacheIdentifierForPayload(payload, true)\n    const cached = blockCache[identifier]\n    // may be undefined\n    return cached\n  }\n\n  async set (payload, requestedBlockNumber, result) {\n    // check if we can cached this result\n    const canCache = this.canCacheResult(payload, result)\n    if (!canCache) return\n    // set the value in the cache\n    const blockCache = this.getBlockCacheForPayload(payload, requestedBlockNumber)\n    const identifier = cacheUtils.cacheIdentifierForPayload(payload, true)\n    blockCache[identifier] = result\n  }\n\n  canCacheRequest (payload) {\n    // check request method\n    if (!cacheUtils.canCache(payload)) {\n      return false\n    }\n    // check blockTag\n    const blockTag = cacheUtils.blockTagForPayload(payload)\n    if (blockTag === 'pending') {\n      return false\n    }\n    // can be cached\n    return true\n  }\n\n  canCacheResult (payload, result) {\n    // never cache empty values (e.g. undefined)\n    if (emptyValues.includes(result)) return\n    // check if transactions have block reference before caching\n    if (['eth_getTransactionByHash', 'eth_getTransactionReceipt'].includes(payload.method)) {\n      if (!result || !result.blockHash || result.blockHash === '0x0000000000000000000000000000000000000000000000000000000000000000') {\n        return false\n      }\n    }\n    // otherwise true\n    return true\n  }\n\n  // removes all block caches with block number lower than `oldBlockHex`\n  clearBefore (oldBlockHex){\n    const self = this\n    const oldBlockNumber = Number.parseInt(oldBlockHex, 16)\n    // clear old caches\n    Object.keys(self.cache)\n      .map(Number)\n      .filter(num => num < oldBlockNumber)\n      .forEach(num => delete self.cache[num])\n  }\n\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}