{"ast":null,"code":"import { disconnect as l, getAccount as h, watchAccount as d, fetchBalance as w, getNetwork as C, watchNetwork as u, switchNetwork as p, fetchEnsName as f, fetchEnsAvatar as m, connect as s, InjectedConnector as g } from \"@wagmi/core\";\nimport { CoinbaseWalletConnector as I } from \"@wagmi/core/connectors/coinbaseWallet\";\nimport { WalletConnectConnector as v } from \"@wagmi/core/connectors/walletConnect\";\nimport { jsonRpcProvider as N } from \"@wagmi/core/providers/jsonRpc\";\nclass P {\n  constructor(n, t) {\n    this.wagmi = {}, this.walletConnectUri = \"\", this.walletConnectVersion = 1, this.chains = [], this.namespace = \"eip155\", this.disconnect = l, this.getAccount = h, this.watchAccount = d, this.fetchBalance = w, this.getNetwork = C, this.watchNetwork = u, this.switchNetwork = p, this.fetchEnsName = f, this.fetchEnsAvatar = m;\n    var e;\n    const o = n.connectors.find(i => i.id === \"walletConnect\");\n    if (!o) throw new Error(\"WalletConnectConnector is required\");\n    this.wagmi = n, this.chains = t, this.walletConnectVersion = Number((e = o.options.version) != null ? e : \"1\");\n  }\n  getDefaultConnectorChainId(n) {\n    return n.chains[0].id;\n  }\n  async connectWalletConnectV1(n, t) {\n    return new Promise((e, o) => {\n      n.once(\"message\", async _ref => {\n        let {\n          type: i\n        } = _ref;\n        if (i === \"connecting\") {\n          const c = (await n.getProvider()).connector;\n          this.walletConnectUri = c.uri, t(c.uri), c.on(\"disconnect\", () => {\n            o(Error());\n          }), c.on(\"connect\", () => {\n            e();\n          });\n        }\n      });\n    });\n  }\n  async connectWalletConnectV2(n, t) {\n    const e = await n.getProvider();\n    let o = \"\";\n    return new Promise(i => {\n      e.once(\"display_uri\", c => {\n        this.walletConnectUri = c, o = c, t(c);\n      }), e.once(\"connect\", () => {\n        o === this.walletConnectUri && i();\n      });\n    });\n  }\n  getDefaultChain() {\n    const n = this.chains.find(t => t.id === 1);\n    return n ?? this.chains[0];\n  }\n  getConnectorById(n) {\n    const t = this.wagmi.connectors.find(e => e.id === n);\n    if (!t) throw new Error(`Connector for id ${n} was not found`);\n    return t;\n  }\n  getConnectors() {\n    return this.wagmi.connectors.filter(n => n.id !== \"walletConnect\");\n  }\n  async connectWalletConnect(n, t) {\n    const e = this.getConnectorById(\"walletConnect\"),\n      o = this.walletConnectVersion === 1,\n      i = t ?? this.getDefaultConnectorChainId(e),\n      c = o ? this.connectWalletConnectV1.bind(this) : this.connectWalletConnectV2.bind(this),\n      [a] = await Promise.all([s({\n        connector: e,\n        chainId: i\n      }), c(e, n)]);\n    return a;\n  }\n  async connectConnector(n, t) {\n    const e = this.getConnectorById(n),\n      o = t ?? this.getDefaultConnectorChainId(e);\n    return await s({\n      connector: e,\n      chainId: o\n    });\n  }\n}\nconst E = \"eip155\";\nfunction j(_ref2) {\n  let {\n    projectId: r\n  } = _ref2;\n  return N({\n    rpc: n => {\n      var t;\n      return [1, 3, 4, 5, 10, 42, 56, 69, 97, 100, 137, 420, 42161, 42220, 43114, 80001, 421611, 421613, 1313161554, 11297108109].includes(n.id) ? {\n        http: `https://rpc.walletconnect.com/v1/?chainId=${E}:${n.id}&projectId=${r}`\n      } : {\n        http: n.rpcUrls.default.http[0],\n        webSocket: (t = n.rpcUrls.default.webSocket) == null ? void 0 : t[0]\n      };\n    }\n  });\n}\nfunction V(_ref3) {\n  let {\n    appName: r,\n    chains: n,\n    version: t,\n    projectId: e\n  } = _ref3;\n  const o = t ?? \"1\";\n  if (o === \"2\" && !e) throw new Error(\"modalConnectors() requires projectId for WalletConnect version 2\");\n  return [new v({\n    chains: n,\n    options: {\n      qrcode: !1,\n      version: o,\n      projectId: e\n    }\n  }), new g({\n    chains: n,\n    options: {\n      shimDisconnect: !0,\n      shimChainChangedDisconnect: !0\n    }\n  }), new I({\n    chains: n,\n    options: {\n      appName: r\n    }\n  })];\n}\nexport { P as EthereumClient, V as modalConnectors, j as walletConnectProvider };","map":{"version":3,"mappings":"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","names":["EthereumClient","constructor","wagmi","chains","walletConnectUri","walletConnectVersion","namespace","disconnect","getAccount","watchAccount","fetchBalance","getNetwork","watchNetwork","switchNetwork","fetchEnsName","fetchEnsAvatar","walletConnect","connectors","find","c","id","Error","Number","_a","options","version","getDefaultConnectorChainId","connector","connectWalletConnectV1","onUri","Promise","resolve","reject","once","type","providerConnector","getProvider","uri","on","connectWalletConnectV2","provider","activeWalletConnectUri","getDefaultChain","mainnet","chain","getConnectorById","item","getConnectors","filter","connectWalletConnect","selectedChainId","isV1","chainId","handleProviderEvents","bind","data","all","connect","connectConnector","connectorId","NAMESPACE","projectId","jsonRpcProvider","rpc","includes","http","rpcUrls","default","webSocket","modalConnectors","appName","WalletConnectConnector","qrcode","InjectedConnector","shimDisconnect","shimChainChangedDisconnect","CoinbaseWalletConnector"],"sources":["C:\\Users\\paete\\Prototype\\nftmusicprotocopy\\client\\node_modules\\@web3modal\\ethereum\\src\\client.ts","C:\\Users\\paete\\Prototype\\nftmusicprotocopy\\client\\node_modules\\@web3modal\\ethereum\\src\\utils.ts"],"sourcesContent":["import type { Chain, Client, Connector } from '@wagmi/core'\nimport {\n  connect,\n  disconnect,\n  fetchBalance,\n  fetchEnsAvatar,\n  fetchEnsName,\n  getAccount,\n  getNetwork,\n  switchNetwork,\n  watchAccount,\n  watchNetwork\n} from '@wagmi/core'\nimport type { ConnectorId } from './types'\n\ntype WalletConnectVersion = 1 | 2\n\nexport class EthereumClient {\n  private readonly wagmi = {} as Client\n  public walletConnectUri = ''\n  public walletConnectVersion: WalletConnectVersion = 1\n  public readonly chains = [] as Chain[]\n\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  public constructor(wagmi: any, chains: Chain[]) {\n    const walletConnect = wagmi.connectors.find((c: Connector) => c.id === 'walletConnect')\n    if (!walletConnect) {\n      throw new Error('WalletConnectConnector is required')\n    }\n    this.wagmi = wagmi\n    this.chains = chains\n    this.walletConnectVersion = Number(walletConnect.options.version ?? '1') as WalletConnectVersion\n  }\n\n  // -- private ------------------------------------------- //\n  private getDefaultConnectorChainId(connector: Connector) {\n    return connector.chains[0].id\n  }\n\n  private async connectWalletConnectV1(connector: Connector, onUri: (uri: string) => void) {\n    return new Promise<void>((resolve, reject) => {\n      connector.once('message', async ({ type }) => {\n        if (type === 'connecting') {\n          const providerConnector = (await connector.getProvider()).connector\n          this.walletConnectUri = providerConnector.uri\n          onUri(providerConnector.uri)\n          providerConnector.on('disconnect', () => {\n            reject(Error())\n          })\n          providerConnector.on('connect', () => {\n            resolve()\n          })\n        }\n      })\n    })\n  }\n\n  private async connectWalletConnectV2(connector: Connector, onUri: (uri: string) => void) {\n    const provider = await connector.getProvider()\n    let activeWalletConnectUri = ''\n\n    return new Promise<void>(resolve => {\n      provider.once('display_uri', (uri: string) => {\n        this.walletConnectUri = uri\n        activeWalletConnectUri = uri\n        onUri(uri)\n      })\n      provider.once('connect', () => {\n        if (activeWalletConnectUri === this.walletConnectUri) {\n          resolve()\n        }\n      })\n    })\n  }\n\n  // -- public web3modal ---------------------------------- //\n  public namespace = 'eip155'\n\n  public getDefaultChain() {\n    const mainnet = this.chains.find(chain => chain.id === 1)\n\n    return mainnet ?? this.chains[0]\n  }\n\n  public getConnectorById(id: ConnectorId | string) {\n    const connector = this.wagmi.connectors.find(item => item.id === id)\n    if (!connector) {\n      throw new Error(`Connector for id ${id} was not found`)\n    }\n\n    return connector\n  }\n\n  public getConnectors() {\n    const connectors = this.wagmi.connectors.filter(connector => connector.id !== 'walletConnect')\n\n    return connectors\n  }\n\n  public async connectWalletConnect(onUri: (uri: string) => void, selectedChainId?: number) {\n    const connector = this.getConnectorById('walletConnect')\n    const isV1 = this.walletConnectVersion === 1\n    const chainId = selectedChainId ?? this.getDefaultConnectorChainId(connector)\n    const handleProviderEvents = isV1\n      ? this.connectWalletConnectV1.bind(this)\n      : this.connectWalletConnectV2.bind(this)\n    const [data] = await Promise.all([\n      connect({ connector, chainId }),\n      handleProviderEvents(connector, onUri)\n    ])\n\n    return data\n  }\n\n  public async connectConnector(connectorId: ConnectorId | string, selectedChainId?: number) {\n    const connector = this.getConnectorById(connectorId)\n    const chainId = selectedChainId ?? this.getDefaultConnectorChainId(connector)\n    const data = await connect({ connector, chainId })\n\n    return data\n  }\n\n  public disconnect = disconnect\n\n  public getAccount = getAccount\n\n  public watchAccount = watchAccount\n\n  public fetchBalance = fetchBalance\n\n  public getNetwork = getNetwork\n\n  public watchNetwork = watchNetwork\n\n  public switchNetwork = switchNetwork\n\n  // -- public web3modal (optional) ----------------------- //\n  public fetchEnsName = fetchEnsName\n\n  public fetchEnsAvatar = fetchEnsAvatar\n}\n","import type { Chain } from '@wagmi/core'\nimport { InjectedConnector } from '@wagmi/core'\nimport { CoinbaseWalletConnector } from '@wagmi/core/connectors/coinbaseWallet'\nimport { WalletConnectConnector } from '@wagmi/core/connectors/walletConnect'\nimport { jsonRpcProvider } from '@wagmi/core/providers/jsonRpc'\nimport type { ModalConnectorsOpts, WalletConnectProviderOpts } from './types'\n\n// -- constants ------------------------------------------------------- //\nexport const NAMESPACE = 'eip155'\n\n// -- providers ------------------------------------------------------- //\nexport function walletConnectProvider<C extends Chain>({ projectId }: WalletConnectProviderOpts) {\n  return jsonRpcProvider<C>({\n    rpc: chain => {\n      const supportedChains = [\n        1, 3, 4, 5, 10, 42, 56, 69, 97, 100, 137, 420, 42161, 42220, 43114, 80001, 421611, 421613,\n        1313161554, 11297108109\n      ]\n\n      if (supportedChains.includes(chain.id)) {\n        return {\n          http: `https://rpc.walletconnect.com/v1/?chainId=${NAMESPACE}:${chain.id}&projectId=${projectId}`\n        }\n      }\n\n      return {\n        http: chain.rpcUrls.default.http[0],\n        webSocket: chain.rpcUrls.default.webSocket?.[0]\n      }\n    }\n  })\n}\n\n// -- connectors ------------------------------------------------------ //\nexport function modalConnectors({ appName, chains, version, projectId }: ModalConnectorsOpts) {\n  const walletConnectVersion = version ?? '1'\n  if (walletConnectVersion === '2' && !projectId) {\n    throw new Error('modalConnectors() requires projectId for WalletConnect version 2')\n  }\n\n  return [\n    new WalletConnectConnector({\n      chains,\n      // @ts-expect-error - projectId is checked above\n      options: { qrcode: false, version: walletConnectVersion, projectId }\n    }),\n    new InjectedConnector({\n      chains,\n      options: { shimDisconnect: true, shimChainChangedDisconnect: true }\n    }),\n    new CoinbaseWalletConnector({ chains, options: { appName } })\n  ]\n}\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}