{"ast":null,"code":"import { markToTrack, getUntracked } from 'proxy-compare';\nconst isObject = x => typeof x === \"object\" && x !== null;\nconst proxyStateMap = /* @__PURE__ */new WeakMap();\nconst refSet = /* @__PURE__ */new WeakSet();\nconst buildProxyFunction = function () {\n  let objectIs = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : Object.is;\n  let newProxy = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : (target, handler) => new Proxy(target, handler);\n  let canProxy = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : x => isObject(x) && !refSet.has(x) && (Array.isArray(x) || !(Symbol.iterator in x)) && !(x instanceof WeakMap) && !(x instanceof WeakSet) && !(x instanceof Error) && !(x instanceof Number) && !(x instanceof Date) && !(x instanceof String) && !(x instanceof RegExp) && !(x instanceof ArrayBuffer);\n  let defaultHandlePromise = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : promise => {\n    switch (promise.status) {\n      case \"fulfilled\":\n        return promise.value;\n      case \"rejected\":\n        throw promise.reason;\n      default:\n        throw promise;\n    }\n  };\n  let snapCache = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : /* @__PURE__ */new WeakMap();\n  let createSnapshot = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : function (target, version) {\n    let handlePromise = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : defaultHandlePromise;\n    const cache = snapCache.get(target);\n    if ((cache == null ? void 0 : cache[0]) === version) {\n      return cache[1];\n    }\n    const snap = Array.isArray(target) ? [] : Object.create(Object.getPrototypeOf(target));\n    markToTrack(snap, true);\n    snapCache.set(target, [version, snap]);\n    Reflect.ownKeys(target).forEach(key => {\n      const value = Reflect.get(target, key);\n      if (refSet.has(value)) {\n        markToTrack(value, false);\n        snap[key] = value;\n      } else if (value instanceof Promise) {\n        Object.defineProperty(snap, key, {\n          get() {\n            return handlePromise(value);\n          }\n        });\n      } else if (proxyStateMap.has(value)) {\n        snap[key] = snapshot(value, handlePromise);\n      } else {\n        snap[key] = value;\n      }\n    });\n    return Object.freeze(snap);\n  };\n  let proxyCache = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : /* @__PURE__ */new WeakMap();\n  let versionHolder = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : [1, 1];\n  let proxyFunction2 = arguments.length > 8 && arguments[8] !== undefined ? arguments[8] : initialObject => {\n    if (!isObject(initialObject)) {\n      throw new Error(\"object required\");\n    }\n    const found = proxyCache.get(initialObject);\n    if (found) {\n      return found;\n    }\n    let version = versionHolder[0];\n    const listeners = /* @__PURE__ */new Set();\n    const notifyUpdate = function (op) {\n      let nextVersion = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : ++versionHolder[0];\n      if (version !== nextVersion) {\n        version = nextVersion;\n        listeners.forEach(listener => listener(op, nextVersion));\n      }\n    };\n    let checkVersion = versionHolder[1];\n    const ensureVersion = function () {\n      let nextCheckVersion = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : ++versionHolder[1];\n      if (checkVersion !== nextCheckVersion && !listeners.size) {\n        checkVersion = nextCheckVersion;\n        propProxyStates.forEach(_ref => {\n          let [propProxyState] = _ref;\n          const propVersion = propProxyState[1](nextCheckVersion);\n          if (propVersion > version) {\n            version = propVersion;\n          }\n        });\n      }\n      return version;\n    };\n    const createPropListener = prop => (op, nextVersion) => {\n      const newOp = [...op];\n      newOp[1] = [prop, ...newOp[1]];\n      notifyUpdate(newOp, nextVersion);\n    };\n    const propProxyStates = /* @__PURE__ */new Map();\n    const addPropListener = (prop, propProxyState) => {\n      if ((import.meta.env && import.meta.env.MODE) !== \"production\" && propProxyStates.has(prop)) {\n        throw new Error(\"prop listener already exists\");\n      }\n      if (listeners.size) {\n        const remove = propProxyState[3](createPropListener(prop));\n        propProxyStates.set(prop, [propProxyState, remove]);\n      } else {\n        propProxyStates.set(prop, [propProxyState]);\n      }\n    };\n    const removePropListener = prop => {\n      var _a;\n      const entry = propProxyStates.get(prop);\n      if (entry) {\n        propProxyStates.delete(prop);\n        (_a = entry[1]) == null ? void 0 : _a.call(entry);\n      }\n    };\n    const addListener = listener => {\n      listeners.add(listener);\n      if (listeners.size === 1) {\n        propProxyStates.forEach((_ref2, prop) => {\n          let [propProxyState, prevRemove] = _ref2;\n          if ((import.meta.env && import.meta.env.MODE) !== \"production\" && prevRemove) {\n            throw new Error(\"remove already exists\");\n          }\n          const remove = propProxyState[3](createPropListener(prop));\n          propProxyStates.set(prop, [propProxyState, remove]);\n        });\n      }\n      const removeListener = () => {\n        listeners.delete(listener);\n        if (listeners.size === 0) {\n          propProxyStates.forEach((_ref3, prop) => {\n            let [propProxyState, remove] = _ref3;\n            if (remove) {\n              remove();\n              propProxyStates.set(prop, [propProxyState]);\n            }\n          });\n        }\n      };\n      return removeListener;\n    };\n    const baseObject = Array.isArray(initialObject) ? [] : Object.create(Object.getPrototypeOf(initialObject));\n    const handler = {\n      deleteProperty(target, prop) {\n        const prevValue = Reflect.get(target, prop);\n        removePropListener(prop);\n        const deleted = Reflect.deleteProperty(target, prop);\n        if (deleted) {\n          notifyUpdate([\"delete\", [prop], prevValue]);\n        }\n        return deleted;\n      },\n      set(target, prop, value, receiver) {\n        var _a;\n        const hasPrevValue = Reflect.has(target, prop);\n        const prevValue = Reflect.get(target, prop, receiver);\n        if (hasPrevValue && objectIs(prevValue, value)) {\n          return true;\n        }\n        removePropListener(prop);\n        if (isObject(value)) {\n          value = getUntracked(value) || value;\n        }\n        let nextValue = value;\n        if ((_a = Object.getOwnPropertyDescriptor(target, prop)) == null ? void 0 : _a.set) ;else if (value instanceof Promise) {\n          value.then(v => {\n            value.status = \"fulfilled\";\n            value.value = v;\n            notifyUpdate([\"resolve\", [prop], v]);\n          }).catch(e => {\n            value.status = \"rejected\";\n            value.reason = e;\n            notifyUpdate([\"reject\", [prop], e]);\n          });\n        } else {\n          if (!proxyStateMap.has(value) && canProxy(value)) {\n            nextValue = proxy(value);\n          }\n          const childProxyState = !refSet.has(nextValue) && proxyStateMap.get(nextValue);\n          if (childProxyState) {\n            addPropListener(prop, childProxyState);\n          }\n        }\n        Reflect.set(target, prop, nextValue, receiver);\n        notifyUpdate([\"set\", [prop], value, prevValue]);\n        return true;\n      }\n    };\n    const proxyObject = newProxy(baseObject, handler);\n    proxyCache.set(initialObject, proxyObject);\n    const proxyState = [baseObject, ensureVersion, createSnapshot, addListener];\n    proxyStateMap.set(proxyObject, proxyState);\n    Reflect.ownKeys(initialObject).forEach(key => {\n      const desc = Object.getOwnPropertyDescriptor(initialObject, key);\n      if (desc.get || desc.set) {\n        Object.defineProperty(baseObject, key, desc);\n      } else {\n        proxyObject[key] = initialObject[key];\n      }\n    });\n    return proxyObject;\n  };\n  return [\n  // public functions\n  proxyFunction2,\n  // shared state\n  proxyStateMap, refSet,\n  // internal things\n  objectIs, newProxy, canProxy, defaultHandlePromise, snapCache, createSnapshot, proxyCache, versionHolder];\n};\nconst [proxyFunction] = buildProxyFunction();\nfunction proxy() {\n  let initialObject = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  return proxyFunction(initialObject);\n}\nfunction getVersion(proxyObject) {\n  const proxyState = proxyStateMap.get(proxyObject);\n  return proxyState == null ? void 0 : proxyState[1]();\n}\nfunction subscribe(proxyObject, callback, notifyInSync) {\n  const proxyState = proxyStateMap.get(proxyObject);\n  if ((import.meta.env && import.meta.env.MODE) !== \"production\" && !proxyState) {\n    console.warn(\"Please use proxy object\");\n  }\n  let promise;\n  const ops = [];\n  const addListener = proxyState[3];\n  let isListenerActive = false;\n  const listener = op => {\n    ops.push(op);\n    if (notifyInSync) {\n      callback(ops.splice(0));\n      return;\n    }\n    if (!promise) {\n      promise = Promise.resolve().then(() => {\n        promise = void 0;\n        if (isListenerActive) {\n          callback(ops.splice(0));\n        }\n      });\n    }\n  };\n  const removeListener = addListener(listener);\n  isListenerActive = true;\n  return () => {\n    isListenerActive = false;\n    removeListener();\n  };\n}\nfunction snapshot(proxyObject, handlePromise) {\n  const proxyState = proxyStateMap.get(proxyObject);\n  if ((import.meta.env && import.meta.env.MODE) !== \"production\" && !proxyState) {\n    console.warn(\"Please use proxy object\");\n  }\n  const [target, ensureVersion, createSnapshot] = proxyState;\n  return createSnapshot(target, ensureVersion(), handlePromise);\n}\nfunction ref(obj) {\n  refSet.add(obj);\n  return obj;\n}\nconst unstable_buildProxyFunction = buildProxyFunction;\nexport { getVersion, proxy, ref, snapshot, subscribe, unstable_buildProxyFunction };","map":{"version":3,"names":["markToTrack","getUntracked","isObject","x","proxyStateMap","WeakMap","refSet","WeakSet","buildProxyFunction","objectIs","Object","is","newProxy","target","handler","Proxy","canProxy","has","Array","isArray","Symbol","iterator","Error","Number","Date","String","RegExp","ArrayBuffer","defaultHandlePromise","promise","status","value","reason","snapCache","createSnapshot","version","handlePromise","cache","get","snap","create","getPrototypeOf","set","Reflect","ownKeys","forEach","key","Promise","defineProperty","snapshot","freeze","proxyCache","versionHolder","proxyFunction2","initialObject","found","listeners","Set","notifyUpdate","op","nextVersion","listener","checkVersion","ensureVersion","nextCheckVersion","size","propProxyStates","propProxyState","propVersion","createPropListener","prop","newOp","Map","addPropListener","import","meta","env","MODE","remove","removePropListener","_a","entry","delete","call","addListener","add","prevRemove","removeListener","baseObject","deleteProperty","prevValue","deleted","receiver","hasPrevValue","nextValue","getOwnPropertyDescriptor","then","v","catch","e","proxy","childProxyState","proxyObject","proxyState","desc","proxyFunction","getVersion","subscribe","callback","notifyInSync","console","warn","ops","isListenerActive","push","splice","resolve","ref","obj","unstable_buildProxyFunction"],"sources":["C:/Users/paete/Prototype/nftmusicProtoCopy/client/node_modules/valtio/esm/vanilla.mjs"],"sourcesContent":["import { markToTrack, getUntracked } from 'proxy-compare';\n\nconst isObject = (x) => typeof x === \"object\" && x !== null;\nconst proxyStateMap = /* @__PURE__ */ new WeakMap();\nconst refSet = /* @__PURE__ */ new WeakSet();\nconst buildProxyFunction = (objectIs = Object.is, newProxy = (target, handler) => new Proxy(target, handler), canProxy = (x) => isObject(x) && !refSet.has(x) && (Array.isArray(x) || !(Symbol.iterator in x)) && !(x instanceof WeakMap) && !(x instanceof WeakSet) && !(x instanceof Error) && !(x instanceof Number) && !(x instanceof Date) && !(x instanceof String) && !(x instanceof RegExp) && !(x instanceof ArrayBuffer), defaultHandlePromise = (promise) => {\n  switch (promise.status) {\n    case \"fulfilled\":\n      return promise.value;\n    case \"rejected\":\n      throw promise.reason;\n    default:\n      throw promise;\n  }\n}, snapCache = /* @__PURE__ */ new WeakMap(), createSnapshot = (target, version, handlePromise = defaultHandlePromise) => {\n  const cache = snapCache.get(target);\n  if ((cache == null ? void 0 : cache[0]) === version) {\n    return cache[1];\n  }\n  const snap = Array.isArray(target) ? [] : Object.create(Object.getPrototypeOf(target));\n  markToTrack(snap, true);\n  snapCache.set(target, [version, snap]);\n  Reflect.ownKeys(target).forEach((key) => {\n    const value = Reflect.get(target, key);\n    if (refSet.has(value)) {\n      markToTrack(value, false);\n      snap[key] = value;\n    } else if (value instanceof Promise) {\n      Object.defineProperty(snap, key, {\n        get() {\n          return handlePromise(value);\n        }\n      });\n    } else if (proxyStateMap.has(value)) {\n      snap[key] = snapshot(value, handlePromise);\n    } else {\n      snap[key] = value;\n    }\n  });\n  return Object.freeze(snap);\n}, proxyCache = /* @__PURE__ */ new WeakMap(), versionHolder = [1, 1], proxyFunction2 = (initialObject) => {\n  if (!isObject(initialObject)) {\n    throw new Error(\"object required\");\n  }\n  const found = proxyCache.get(initialObject);\n  if (found) {\n    return found;\n  }\n  let version = versionHolder[0];\n  const listeners = /* @__PURE__ */ new Set();\n  const notifyUpdate = (op, nextVersion = ++versionHolder[0]) => {\n    if (version !== nextVersion) {\n      version = nextVersion;\n      listeners.forEach((listener) => listener(op, nextVersion));\n    }\n  };\n  let checkVersion = versionHolder[1];\n  const ensureVersion = (nextCheckVersion = ++versionHolder[1]) => {\n    if (checkVersion !== nextCheckVersion && !listeners.size) {\n      checkVersion = nextCheckVersion;\n      propProxyStates.forEach(([propProxyState]) => {\n        const propVersion = propProxyState[1](nextCheckVersion);\n        if (propVersion > version) {\n          version = propVersion;\n        }\n      });\n    }\n    return version;\n  };\n  const createPropListener = (prop) => (op, nextVersion) => {\n    const newOp = [...op];\n    newOp[1] = [prop, ...newOp[1]];\n    notifyUpdate(newOp, nextVersion);\n  };\n  const propProxyStates = /* @__PURE__ */ new Map();\n  const addPropListener = (prop, propProxyState) => {\n    if ((import.meta.env && import.meta.env.MODE) !== \"production\" && propProxyStates.has(prop)) {\n      throw new Error(\"prop listener already exists\");\n    }\n    if (listeners.size) {\n      const remove = propProxyState[3](createPropListener(prop));\n      propProxyStates.set(prop, [propProxyState, remove]);\n    } else {\n      propProxyStates.set(prop, [propProxyState]);\n    }\n  };\n  const removePropListener = (prop) => {\n    var _a;\n    const entry = propProxyStates.get(prop);\n    if (entry) {\n      propProxyStates.delete(prop);\n      (_a = entry[1]) == null ? void 0 : _a.call(entry);\n    }\n  };\n  const addListener = (listener) => {\n    listeners.add(listener);\n    if (listeners.size === 1) {\n      propProxyStates.forEach(([propProxyState, prevRemove], prop) => {\n        if ((import.meta.env && import.meta.env.MODE) !== \"production\" && prevRemove) {\n          throw new Error(\"remove already exists\");\n        }\n        const remove = propProxyState[3](createPropListener(prop));\n        propProxyStates.set(prop, [propProxyState, remove]);\n      });\n    }\n    const removeListener = () => {\n      listeners.delete(listener);\n      if (listeners.size === 0) {\n        propProxyStates.forEach(([propProxyState, remove], prop) => {\n          if (remove) {\n            remove();\n            propProxyStates.set(prop, [propProxyState]);\n          }\n        });\n      }\n    };\n    return removeListener;\n  };\n  const baseObject = Array.isArray(initialObject) ? [] : Object.create(Object.getPrototypeOf(initialObject));\n  const handler = {\n    deleteProperty(target, prop) {\n      const prevValue = Reflect.get(target, prop);\n      removePropListener(prop);\n      const deleted = Reflect.deleteProperty(target, prop);\n      if (deleted) {\n        notifyUpdate([\"delete\", [prop], prevValue]);\n      }\n      return deleted;\n    },\n    set(target, prop, value, receiver) {\n      var _a;\n      const hasPrevValue = Reflect.has(target, prop);\n      const prevValue = Reflect.get(target, prop, receiver);\n      if (hasPrevValue && objectIs(prevValue, value)) {\n        return true;\n      }\n      removePropListener(prop);\n      if (isObject(value)) {\n        value = getUntracked(value) || value;\n      }\n      let nextValue = value;\n      if ((_a = Object.getOwnPropertyDescriptor(target, prop)) == null ? void 0 : _a.set) ; else if (value instanceof Promise) {\n        value.then((v) => {\n          value.status = \"fulfilled\";\n          value.value = v;\n          notifyUpdate([\"resolve\", [prop], v]);\n        }).catch((e) => {\n          value.status = \"rejected\";\n          value.reason = e;\n          notifyUpdate([\"reject\", [prop], e]);\n        });\n      } else {\n        if (!proxyStateMap.has(value) && canProxy(value)) {\n          nextValue = proxy(value);\n        }\n        const childProxyState = !refSet.has(nextValue) && proxyStateMap.get(nextValue);\n        if (childProxyState) {\n          addPropListener(prop, childProxyState);\n        }\n      }\n      Reflect.set(target, prop, nextValue, receiver);\n      notifyUpdate([\"set\", [prop], value, prevValue]);\n      return true;\n    }\n  };\n  const proxyObject = newProxy(baseObject, handler);\n  proxyCache.set(initialObject, proxyObject);\n  const proxyState = [\n    baseObject,\n    ensureVersion,\n    createSnapshot,\n    addListener\n  ];\n  proxyStateMap.set(proxyObject, proxyState);\n  Reflect.ownKeys(initialObject).forEach((key) => {\n    const desc = Object.getOwnPropertyDescriptor(\n      initialObject,\n      key\n    );\n    if (desc.get || desc.set) {\n      Object.defineProperty(baseObject, key, desc);\n    } else {\n      proxyObject[key] = initialObject[key];\n    }\n  });\n  return proxyObject;\n}) => [\n  // public functions\n  proxyFunction2,\n  // shared state\n  proxyStateMap,\n  refSet,\n  // internal things\n  objectIs,\n  newProxy,\n  canProxy,\n  defaultHandlePromise,\n  snapCache,\n  createSnapshot,\n  proxyCache,\n  versionHolder\n];\nconst [proxyFunction] = buildProxyFunction();\nfunction proxy(initialObject = {}) {\n  return proxyFunction(initialObject);\n}\nfunction getVersion(proxyObject) {\n  const proxyState = proxyStateMap.get(proxyObject);\n  return proxyState == null ? void 0 : proxyState[1]();\n}\nfunction subscribe(proxyObject, callback, notifyInSync) {\n  const proxyState = proxyStateMap.get(proxyObject);\n  if ((import.meta.env && import.meta.env.MODE) !== \"production\" && !proxyState) {\n    console.warn(\"Please use proxy object\");\n  }\n  let promise;\n  const ops = [];\n  const addListener = proxyState[3];\n  let isListenerActive = false;\n  const listener = (op) => {\n    ops.push(op);\n    if (notifyInSync) {\n      callback(ops.splice(0));\n      return;\n    }\n    if (!promise) {\n      promise = Promise.resolve().then(() => {\n        promise = void 0;\n        if (isListenerActive) {\n          callback(ops.splice(0));\n        }\n      });\n    }\n  };\n  const removeListener = addListener(listener);\n  isListenerActive = true;\n  return () => {\n    isListenerActive = false;\n    removeListener();\n  };\n}\nfunction snapshot(proxyObject, handlePromise) {\n  const proxyState = proxyStateMap.get(proxyObject);\n  if ((import.meta.env && import.meta.env.MODE) !== \"production\" && !proxyState) {\n    console.warn(\"Please use proxy object\");\n  }\n  const [target, ensureVersion, createSnapshot] = proxyState;\n  return createSnapshot(target, ensureVersion(), handlePromise);\n}\nfunction ref(obj) {\n  refSet.add(obj);\n  return obj;\n}\nconst unstable_buildProxyFunction = buildProxyFunction;\n\nexport { getVersion, proxy, ref, snapshot, subscribe, unstable_buildProxyFunction };\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}