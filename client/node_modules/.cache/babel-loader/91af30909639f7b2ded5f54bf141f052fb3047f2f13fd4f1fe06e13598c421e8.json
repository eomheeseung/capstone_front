{"ast":null,"code":"import f from \"pino\";\nimport g from \"@walletconnect/sign-client\";\nimport { getSdkError as P, isValidArray as w } from \"@walletconnect/utils\";\nimport { getDefaultLoggerOptions as C } from \"@walletconnect/logger\";\nimport { JsonRpcProvider as a } from \"@walletconnect/jsonrpc-provider\";\nimport h, { HttpConnection as I } from \"@walletconnect/jsonrpc-http-connection\";\nimport y from \"events\";\nfunction E(i) {\n  var e;\n  const t = (e = i[Object.keys(i)[0]]) == null ? void 0 : e.chains[0];\n  return [t.split(\":\")[0], t.split(\":\")[1]];\n}\nfunction r(i, e) {\n  let t;\n  return e.rpcMap && (t = e.rpcMap[O([i])]), t;\n}\nfunction O(i) {\n  return Number(i[0].split(\":\")[1]);\n}\nconst o = (i, e) => {\n  const t = s => {\n    s.request !== e.request || s.topic !== e.topic || (i.events.removeListener(\"session_request_sent\", t), q());\n  };\n  i.on(\"session_request_sent\", t);\n};\nfunction q() {\n  if (typeof window < \"u\") try {\n    const i = window.localStorage.getItem(\"WALLETCONNECT_DEEPLINK_CHOICE\");\n    if (i) {\n      const e = JSON.parse(i);\n      window.open(e.href, \"_self\", \"noreferrer noopener\");\n    }\n  } catch (i) {\n    console.error(i);\n  }\n}\nclass H {\n  constructor(e) {\n    this.name = \"eip155\", this.namespace = e.namespace, this.client = e.client, this.events = e.events, this.httpProviders = this.createHttpProviders(), this.chainId = this.getDefaultChainId();\n  }\n  async request(e) {\n    var t;\n    switch (e.request.method) {\n      case \"eth_requestAccounts\":\n        return this.getAccounts();\n      case \"eth_accounts\":\n        return this.getAccounts();\n      case \"wallet_switchEthereumChain\":\n        {\n          const s = e.request.params ? (t = e.request.params[0]) == null ? void 0 : t.chainId : \"0x0\";\n          return this.setDefaultChain(parseInt(s, 16).toString()), null;\n        }\n      case \"eth_chainId\":\n        return this.getDefaultChainId();\n    }\n    return this.namespace.methods.includes(e.request.method) ? (o(this.client, e), await this.client.request(e)) : this.getHttpProvider().request(e.request);\n  }\n  updateNamespace(e) {\n    this.namespace = Object.assign(this.namespace, e);\n  }\n  setDefaultChain(e, t) {\n    if (this.chainId = parseInt(e), !this.httpProviders[e]) {\n      const s = t || r(`${this.name}:${e}`, this.namespace);\n      if (!s) throw new Error(`No RPC url provided for chainId: ${e}`);\n      this.setHttpProvider(e, s);\n    }\n    this.events.emit(\"chainChanged\", this.chainId);\n  }\n  requestAccounts() {\n    return this.getAccounts();\n  }\n  createHttpProvider(e, t) {\n    const s = t || r(e, this.namespace);\n    return typeof s > \"u\" ? void 0 : new a(new I(s));\n  }\n  setHttpProvider(e, t) {\n    const s = this.createHttpProvider(e, t);\n    s && (this.httpProviders[e] = s);\n  }\n  createHttpProviders() {\n    const e = {};\n    return this.namespace.chains.forEach(t => {\n      e[t] = this.createHttpProvider(t);\n    }), e;\n  }\n  getAccounts() {\n    const e = this.namespace.accounts;\n    return e ? e.filter(t => t.split(\":\")[1] === this.chainId.toString()).map(t => t.split(\":\")[2]) || [] : [];\n  }\n  getDefaultChainId() {\n    if (this.chainId) return this.chainId;\n    const e = this.namespace.chains[0];\n    if (!e) throw new Error(\"ChainId not found\");\n    return parseInt(e.split(\":\")[1]);\n  }\n  getHttpProvider() {\n    const e = `${this.name}:${this.chainId}`,\n      t = this.httpProviders[e];\n    if (typeof t > \"u\") throw new Error(`JSON-RPC provider for ${e} not found`);\n    return t;\n  }\n}\nclass $ {\n  constructor(e) {\n    this.name = \"solana\", this.namespace = e.namespace, this.events = e.events, this.client = e.client, this.chainId = this.getDefaultChainId(), this.httpProviders = this.createHttpProviders();\n  }\n  updateNamespace(e) {\n    this.namespace = Object.assign(this.namespace, e);\n  }\n  requestAccounts() {\n    return this.getAccounts();\n  }\n  getAccounts() {\n    const e = this.namespace.accounts;\n    return e ? e.filter(t => t.split(\":\")[1] === this.chainId.toString()).map(t => t.split(\":\")[2]) || [] : [];\n  }\n  createHttpProviders() {\n    const e = {};\n    return this.namespace.chains.forEach(t => {\n      e[t] = this.createHttpProvider(t);\n    }), e;\n  }\n  getDefaultChainId() {\n    if (this.chainId) return this.chainId;\n    const e = this.namespace.chains[0];\n    if (!e) throw new Error(\"ChainId not found\");\n    return e.split(\":\")[1];\n  }\n  request(e) {\n    return this.namespace.methods.includes(e.request.method) ? (o(this.client, e), this.client.request(e)) : this.getHttpProvider().request(e.request);\n  }\n  getHttpProvider() {\n    const e = `${this.name}:${this.chainId}`,\n      t = this.httpProviders[e];\n    if (typeof t > \"u\") throw new Error(`JSON-RPC provider for ${e} not found`);\n    return t;\n  }\n  setDefaultChain(e, t) {\n    if (this.chainId = e, !this.httpProviders[e]) {\n      const s = t || r(`${this.name}:${e}`, this.namespace);\n      if (!s) throw new Error(`No RPC url provided for chainId: ${e}`);\n      this.setHttpProvider(e, s);\n    }\n    this.events.emit(\"chainChanged\", this.chainId);\n  }\n  setHttpProvider(e, t) {\n    const s = this.createHttpProvider(e, t);\n    s && (this.httpProviders[e] = s);\n  }\n  createHttpProvider(e, t) {\n    const s = t || r(e, this.namespace);\n    return typeof s > \"u\" ? void 0 : new a(new h(s));\n  }\n}\nclass b {\n  constructor(e) {\n    this.name = \"cosmos\", this.namespace = e.namespace, this.events = e.events, this.client = e.client, this.chainId = this.getDefaultChainId(), this.httpProviders = this.createHttpProviders();\n  }\n  updateNamespace(e) {\n    this.namespace = Object.assign(this.namespace, e);\n  }\n  requestAccounts() {\n    return this.getAccounts();\n  }\n  getAccounts() {\n    const e = this.namespace.accounts;\n    return e ? e.filter(t => t.split(\":\")[1] === this.chainId.toString()).map(t => t.split(\":\")[2]) || [] : [];\n  }\n  createHttpProviders() {\n    const e = {};\n    return this.namespace.chains.forEach(t => {\n      e[t] = this.createHttpProvider(t);\n    }), e;\n  }\n  getDefaultChainId() {\n    if (this.chainId) return this.chainId;\n    const e = this.namespace.chains[0];\n    if (!e) throw new Error(\"ChainId not found\");\n    return e.split(\":\")[1];\n  }\n  request(e) {\n    return this.namespace.methods.includes(e.request.method) ? (o(this.client, e), this.client.request(e)) : this.getHttpProvider().request(e.request);\n  }\n  getHttpProvider() {\n    const e = `${this.name}:${this.chainId}`,\n      t = this.httpProviders[e];\n    if (typeof t > \"u\") throw new Error(`JSON-RPC provider for ${e} not found`);\n    return t;\n  }\n  setDefaultChain(e, t) {\n    if (this.chainId = e, !this.httpProviders[e]) {\n      const s = t || r(`${this.name}:${e}`, this.namespace);\n      if (!s) throw new Error(`No RPC url provided for chainId: ${e}`);\n      this.setHttpProvider(e, s);\n    }\n    this.events.emit(\"chainChanged\", this.chainId);\n  }\n  setHttpProvider(e, t) {\n    const s = this.createHttpProvider(e, t);\n    s && (this.httpProviders[e] = s);\n  }\n  createHttpProvider(e, t) {\n    const s = t || r(e, this.namespace);\n    return typeof s > \"u\" ? void 0 : new a(new h(s));\n  }\n}\nclass N {\n  constructor(e) {\n    this.name = \"cip34\", this.namespace = e.namespace, this.events = e.events, this.client = e.client, this.chainId = this.getDefaultChainId(), this.httpProviders = this.createHttpProviders();\n  }\n  updateNamespace(e) {\n    this.namespace = Object.assign(this.namespace, e);\n  }\n  requestAccounts() {\n    return this.getAccounts();\n  }\n  getAccounts() {\n    const e = this.namespace.accounts;\n    return e ? e.filter(t => t.split(\":\")[1] === this.chainId.toString()).map(t => t.split(\":\")[2]) || [] : [];\n  }\n  createHttpProviders() {\n    const e = {};\n    return this.namespace.chains.forEach(t => {\n      e[t] = this.createHttpProvider(t);\n    }), e;\n  }\n  getDefaultChainId() {\n    if (this.chainId) return this.chainId;\n    const e = this.namespace.chains[0];\n    if (!e) throw new Error(\"ChainId not found\");\n    return e.split(\":\")[1];\n  }\n  request(e) {\n    return this.namespace.methods.includes(e.request.method) ? (o(this.client, e), this.client.request(e)) : this.getHttpProvider().request(e.request);\n  }\n  getHttpProvider() {\n    const e = `${this.name}:${this.chainId}`,\n      t = this.httpProviders[e];\n    if (typeof t > \"u\") throw new Error(`JSON-RPC provider for ${e} not found`);\n    return t;\n  }\n  setDefaultChain(e, t) {\n    if (this.chainId = e, !this.httpProviders[e]) {\n      const s = t || r(`${this.name}:${e}`, this.namespace);\n      if (!s) throw new Error(`No RPC url provided for chainId: ${e}`);\n      this.setHttpProvider(e, s);\n    }\n    this.events.emit(\"chainChanged\", this.chainId);\n  }\n  setHttpProvider(e, t) {\n    const s = this.createHttpProvider(e, t);\n    s && (this.httpProviders[e] = s);\n  }\n  createHttpProvider(e, t) {\n    const s = t || r(e, this.namespace);\n    return typeof s > \"u\" ? void 0 : new a(new h(s));\n  }\n}\nconst p = \"error\",\n  S = \"wss://relay.walletconnect.com\",\n  A = \"wc\",\n  D = \"universal_provider\",\n  d = `${A}@${2}:${D}:`;\nvar _ = Object.defineProperty,\n  k = Object.defineProperties,\n  j = Object.getOwnPropertyDescriptors,\n  l = Object.getOwnPropertySymbols,\n  R = Object.prototype.hasOwnProperty,\n  L = Object.prototype.propertyIsEnumerable,\n  u = (i, e, t) => e in i ? _(i, e, {\n    enumerable: !0,\n    configurable: !0,\n    writable: !0,\n    value: t\n  }) : i[e] = t,\n  v = (i, e) => {\n    for (var t in e || (e = {})) R.call(e, t) && u(i, t, e[t]);\n    if (l) for (var t of l(e)) L.call(e, t) && u(i, t, e[t]);\n    return i;\n  },\n  U = (i, e) => k(i, j(e));\nclass c {\n  constructor(e) {\n    this.events = new y(), this.rpcProviders = {}, this.providerOpts = e, this.logger = typeof e?.logger < \"u\" && typeof e?.logger != \"string\" ? e.logger : f(C({\n      level: e?.logger || p\n    }));\n  }\n  static async init(e) {\n    const t = new c(e);\n    return await t.initialize(), t;\n  }\n  async request(e, t) {\n    const [s, n] = this.validateChain(t);\n    if (!this.session) throw new Error(\"Please call connect() before request()\");\n    return await this.getProvider(s).request({\n      request: v({}, e),\n      chainId: `${s}:${n}`,\n      topic: this.session.topic\n    });\n  }\n  sendAsync(e, t, s) {\n    this.request(e, s).then(n => t(null, n)).catch(n => t(n, void 0));\n  }\n  async enable() {\n    if (!this.client) throw new Error(\"Sign Client not initialized\");\n    return this.session || (await this.connect({\n      namespaces: this.namespaces,\n      optionalNamespaces: this.optionalNamespaces,\n      sessionProperties: this.sessionProperties\n    })), await this.requestAccounts();\n  }\n  async disconnect() {\n    var e;\n    if (!this.session) throw new Error(\"Please call connect() before enable()\");\n    await this.client.disconnect({\n      topic: (e = this.session) == null ? void 0 : e.topic,\n      reason: P(\"USER_DISCONNECTED\")\n    }), await this.cleanup();\n  }\n  async connect(e) {\n    if (!this.client) throw new Error(\"Sign Client not initialized\");\n    if (this.setNamespaces(e), await this.cleanupPendingPairings(), this.createProviders(), !e.skipPairing) return await this.pair(e.pairingTopic);\n  }\n  on(e, t) {\n    this.events.on(e, t);\n  }\n  once(e, t) {\n    this.events.once(e, t);\n  }\n  removeListener(e, t) {\n    this.events.removeListener(e, t);\n  }\n  off(e, t) {\n    this.events.off(e, t);\n  }\n  get isWalletConnect() {\n    return !0;\n  }\n  async pair(e) {\n    const {\n      uri: t,\n      approval: s\n    } = await this.client.connect({\n      pairingTopic: e,\n      requiredNamespaces: this.namespaces,\n      optionalNamespaces: this.optionalNamespaces,\n      sessionProperties: this.sessionProperties\n    });\n    return t && (this.uri = t, this.events.emit(\"display_uri\", t)), this.session = await s(), this.onSessionUpdate(), this.onConnect(), this.session;\n  }\n  setDefaultChain(e, t) {\n    try {\n      const [s, n] = this.validateChain(e);\n      this.getProvider(s).setDefaultChain(n, t);\n    } catch (s) {\n      if (!/Please call connect/.test(s.message)) throw s;\n    }\n  }\n  async cleanupPendingPairings() {\n    let e = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    this.logger.info(\"Cleaning up inactive pairings...\");\n    const t = this.client.pairing.getAll();\n    if (w(t)) {\n      for (const s of t) e.deletePairings ? this.client.core.expirer.set(s.topic, 0) : await this.client.core.relayer.subscriber.unsubscribe(s.topic);\n      this.logger.info(`Inactive pairings cleared: ${t.length}`);\n    }\n  }\n  async checkStorage() {\n    if (this.namespaces = (await this.client.core.storage.getItem(`${d}/namespaces`)) || {}, this.namespaces && this.createProviders(), this.client.session.length) {\n      const e = this.client.session.keys.length - 1;\n      this.session = this.client.session.get(this.client.session.keys[e]), this.onSessionUpdate();\n    }\n  }\n  async initialize() {\n    this.logger.trace(\"Initialized\"), await this.createClient(), this.checkStorage(), this.registerEventListeners();\n  }\n  async createClient() {\n    this.client = this.providerOpts.client || (await g.init({\n      logger: this.providerOpts.logger || p,\n      relayUrl: this.providerOpts.relayUrl || S,\n      projectId: this.providerOpts.projectId,\n      metadata: this.providerOpts.metadata,\n      storageOptions: this.providerOpts.storageOptions,\n      name: this.providerOpts.name\n    })), this.logger.trace(\"SignClient Initialized\");\n  }\n  createProviders() {\n    if (!this.client) throw new Error(\"Sign Client not initialized\");\n    Object.keys(this.namespaces).forEach(e => {\n      var t;\n      const s = Object.assign({}, this.namespaces[e], (t = this.optionalNamespaces) == null ? void 0 : t[e]);\n      switch (e) {\n        case \"eip155\":\n          this.rpcProviders[e] = new H({\n            client: this.client,\n            namespace: s,\n            events: this.events\n          });\n          break;\n        case \"solana\":\n          this.rpcProviders[e] = new $({\n            client: this.client,\n            namespace: s,\n            events: this.events\n          });\n          break;\n        case \"cosmos\":\n          this.rpcProviders[e] = new b({\n            client: this.client,\n            namespace: s,\n            events: this.events\n          });\n          break;\n        case \"polkadot\":\n          break;\n        case \"cip34\":\n          this.rpcProviders[e] = new N({\n            client: this.client,\n            namespace: s,\n            events: this.events\n          });\n          break;\n      }\n    });\n  }\n  registerEventListeners() {\n    if (typeof this.client > \"u\") throw new Error(\"Sign Client is not initialized\");\n    this.client.on(\"session_ping\", e => {\n      this.events.emit(\"session_ping\", e);\n    }), this.client.on(\"session_event\", e => {\n      const {\n          params: t\n        } = e,\n        {\n          event: s\n        } = t;\n      s.name === \"accountsChanged\" ? this.events.emit(\"accountsChanged\", s.data) : s.name === \"chainChanged\" ? this.onChainChanged(s.data, t.chainId) : this.events.emit(s.name, s.data), this.events.emit(\"session_event\", e);\n    }), this.client.on(\"session_update\", _ref => {\n      let {\n        topic: e,\n        params: t\n      } = _ref;\n      var s;\n      const {\n          namespaces: n\n        } = t,\n        m = (s = this.client) == null ? void 0 : s.session.get(e);\n      this.session = U(v({}, m), {\n        namespaces: n\n      }), this.onSessionUpdate(), this.events.emit(\"session_update\", {\n        topic: e,\n        params: t\n      });\n    }), this.client.on(\"session_delete\", async e => {\n      await this.cleanup(), this.events.emit(\"session_delete\", e);\n    });\n  }\n  getProvider(e) {\n    if (!this.rpcProviders[e]) throw new Error(`Provider not found: ${e}`);\n    return this.rpcProviders[e];\n  }\n  onSessionUpdate() {\n    Object.keys(this.rpcProviders).forEach(e => {\n      var t;\n      this.getProvider(e).updateNamespace((t = this.session) == null ? void 0 : t.namespaces[e]);\n    });\n  }\n  setNamespaces(e) {\n    const {\n      namespaces: t,\n      optionalNamespaces: s,\n      sessionProperties: n\n    } = e;\n    if (!t || !Object.keys(t).length) throw new Error(\"Namespaces must be not empty\");\n    this.client.core.storage.setItem(`${d}/namespaces`, t), this.namespaces = t, this.optionalNamespaces = s, this.sessionProperties = n;\n  }\n  validateChain(e) {\n    const [t, s] = e?.split(\":\") || [\"\", \"\"];\n    if (t && !Object.keys(this.namespaces).includes(t)) throw new Error(`Namespace '${t}' is not configured. Please call connect() first with namespace config.`);\n    return !t || !s ? E(this.namespaces) : [t, s];\n  }\n  async requestAccounts() {\n    const [e] = this.validateChain();\n    return await this.getProvider(e).requestAccounts();\n  }\n  onChainChanged(e, t) {\n    const [s, n] = this.validateChain(t);\n    this.getProvider(s).setDefaultChain(n), this.events.emit(\"chainChanged\", e);\n  }\n  onConnect() {\n    this.events.emit(\"connect\", {\n      session: this.session\n    });\n  }\n  async cleanup() {\n    this.session = void 0, await this.cleanupPendingPairings({\n      deletePairings: !0\n    });\n  }\n}\nconst T = c;\nexport { T as UniversalProvider, c as default };","map":{"version":3,"mappings":"","names":[],"sources":[],"sourcesContent":["import f from\"pino\";import g from\"@walletconnect/sign-client\";import{getSdkError as P,isValidArray as w}from\"@walletconnect/utils\";import{getDefaultLoggerOptions as C}from\"@walletconnect/logger\";import{JsonRpcProvider as a}from\"@walletconnect/jsonrpc-provider\";import h,{HttpConnection as I}from\"@walletconnect/jsonrpc-http-connection\";import y from\"events\";function E(i){var e;const t=(e=i[Object.keys(i)[0]])==null?void 0:e.chains[0];return[t.split(\":\")[0],t.split(\":\")[1]]}function r(i,e){let t;return e.rpcMap&&(t=e.rpcMap[O([i])]),t}function O(i){return Number(i[0].split(\":\")[1])}const o=(i,e)=>{const t=s=>{s.request!==e.request||s.topic!==e.topic||(i.events.removeListener(\"session_request_sent\",t),q())};i.on(\"session_request_sent\",t)};function q(){if(typeof window<\"u\")try{const i=window.localStorage.getItem(\"WALLETCONNECT_DEEPLINK_CHOICE\");if(i){const e=JSON.parse(i);window.open(e.href,\"_self\",\"noreferrer noopener\")}}catch(i){console.error(i)}}class H{constructor(e){this.name=\"eip155\",this.namespace=e.namespace,this.client=e.client,this.events=e.events,this.httpProviders=this.createHttpProviders(),this.chainId=this.getDefaultChainId()}async request(e){var t;switch(e.request.method){case\"eth_requestAccounts\":return this.getAccounts();case\"eth_accounts\":return this.getAccounts();case\"wallet_switchEthereumChain\":{const s=e.request.params?(t=e.request.params[0])==null?void 0:t.chainId:\"0x0\";return this.setDefaultChain(parseInt(s,16).toString()),null}case\"eth_chainId\":return this.getDefaultChainId()}return this.namespace.methods.includes(e.request.method)?(o(this.client,e),await this.client.request(e)):this.getHttpProvider().request(e.request)}updateNamespace(e){this.namespace=Object.assign(this.namespace,e)}setDefaultChain(e,t){if(this.chainId=parseInt(e),!this.httpProviders[e]){const s=t||r(`${this.name}:${e}`,this.namespace);if(!s)throw new Error(`No RPC url provided for chainId: ${e}`);this.setHttpProvider(e,s)}this.events.emit(\"chainChanged\",this.chainId)}requestAccounts(){return this.getAccounts()}createHttpProvider(e,t){const s=t||r(e,this.namespace);return typeof s>\"u\"?void 0:new a(new I(s))}setHttpProvider(e,t){const s=this.createHttpProvider(e,t);s&&(this.httpProviders[e]=s)}createHttpProviders(){const e={};return this.namespace.chains.forEach(t=>{e[t]=this.createHttpProvider(t)}),e}getAccounts(){const e=this.namespace.accounts;return e?e.filter(t=>t.split(\":\")[1]===this.chainId.toString()).map(t=>t.split(\":\")[2])||[]:[]}getDefaultChainId(){if(this.chainId)return this.chainId;const e=this.namespace.chains[0];if(!e)throw new Error(\"ChainId not found\");return parseInt(e.split(\":\")[1])}getHttpProvider(){const e=`${this.name}:${this.chainId}`,t=this.httpProviders[e];if(typeof t>\"u\")throw new Error(`JSON-RPC provider for ${e} not found`);return t}}class ${constructor(e){this.name=\"solana\",this.namespace=e.namespace,this.events=e.events,this.client=e.client,this.chainId=this.getDefaultChainId(),this.httpProviders=this.createHttpProviders()}updateNamespace(e){this.namespace=Object.assign(this.namespace,e)}requestAccounts(){return this.getAccounts()}getAccounts(){const e=this.namespace.accounts;return e?e.filter(t=>t.split(\":\")[1]===this.chainId.toString()).map(t=>t.split(\":\")[2])||[]:[]}createHttpProviders(){const e={};return this.namespace.chains.forEach(t=>{e[t]=this.createHttpProvider(t)}),e}getDefaultChainId(){if(this.chainId)return this.chainId;const e=this.namespace.chains[0];if(!e)throw new Error(\"ChainId not found\");return e.split(\":\")[1]}request(e){return this.namespace.methods.includes(e.request.method)?(o(this.client,e),this.client.request(e)):this.getHttpProvider().request(e.request)}getHttpProvider(){const e=`${this.name}:${this.chainId}`,t=this.httpProviders[e];if(typeof t>\"u\")throw new Error(`JSON-RPC provider for ${e} not found`);return t}setDefaultChain(e,t){if(this.chainId=e,!this.httpProviders[e]){const s=t||r(`${this.name}:${e}`,this.namespace);if(!s)throw new Error(`No RPC url provided for chainId: ${e}`);this.setHttpProvider(e,s)}this.events.emit(\"chainChanged\",this.chainId)}setHttpProvider(e,t){const s=this.createHttpProvider(e,t);s&&(this.httpProviders[e]=s)}createHttpProvider(e,t){const s=t||r(e,this.namespace);return typeof s>\"u\"?void 0:new a(new h(s))}}class b{constructor(e){this.name=\"cosmos\",this.namespace=e.namespace,this.events=e.events,this.client=e.client,this.chainId=this.getDefaultChainId(),this.httpProviders=this.createHttpProviders()}updateNamespace(e){this.namespace=Object.assign(this.namespace,e)}requestAccounts(){return this.getAccounts()}getAccounts(){const e=this.namespace.accounts;return e?e.filter(t=>t.split(\":\")[1]===this.chainId.toString()).map(t=>t.split(\":\")[2])||[]:[]}createHttpProviders(){const e={};return this.namespace.chains.forEach(t=>{e[t]=this.createHttpProvider(t)}),e}getDefaultChainId(){if(this.chainId)return this.chainId;const e=this.namespace.chains[0];if(!e)throw new Error(\"ChainId not found\");return e.split(\":\")[1]}request(e){return this.namespace.methods.includes(e.request.method)?(o(this.client,e),this.client.request(e)):this.getHttpProvider().request(e.request)}getHttpProvider(){const e=`${this.name}:${this.chainId}`,t=this.httpProviders[e];if(typeof t>\"u\")throw new Error(`JSON-RPC provider for ${e} not found`);return t}setDefaultChain(e,t){if(this.chainId=e,!this.httpProviders[e]){const s=t||r(`${this.name}:${e}`,this.namespace);if(!s)throw new Error(`No RPC url provided for chainId: ${e}`);this.setHttpProvider(e,s)}this.events.emit(\"chainChanged\",this.chainId)}setHttpProvider(e,t){const s=this.createHttpProvider(e,t);s&&(this.httpProviders[e]=s)}createHttpProvider(e,t){const s=t||r(e,this.namespace);return typeof s>\"u\"?void 0:new a(new h(s))}}class N{constructor(e){this.name=\"cip34\",this.namespace=e.namespace,this.events=e.events,this.client=e.client,this.chainId=this.getDefaultChainId(),this.httpProviders=this.createHttpProviders()}updateNamespace(e){this.namespace=Object.assign(this.namespace,e)}requestAccounts(){return this.getAccounts()}getAccounts(){const e=this.namespace.accounts;return e?e.filter(t=>t.split(\":\")[1]===this.chainId.toString()).map(t=>t.split(\":\")[2])||[]:[]}createHttpProviders(){const e={};return this.namespace.chains.forEach(t=>{e[t]=this.createHttpProvider(t)}),e}getDefaultChainId(){if(this.chainId)return this.chainId;const e=this.namespace.chains[0];if(!e)throw new Error(\"ChainId not found\");return e.split(\":\")[1]}request(e){return this.namespace.methods.includes(e.request.method)?(o(this.client,e),this.client.request(e)):this.getHttpProvider().request(e.request)}getHttpProvider(){const e=`${this.name}:${this.chainId}`,t=this.httpProviders[e];if(typeof t>\"u\")throw new Error(`JSON-RPC provider for ${e} not found`);return t}setDefaultChain(e,t){if(this.chainId=e,!this.httpProviders[e]){const s=t||r(`${this.name}:${e}`,this.namespace);if(!s)throw new Error(`No RPC url provided for chainId: ${e}`);this.setHttpProvider(e,s)}this.events.emit(\"chainChanged\",this.chainId)}setHttpProvider(e,t){const s=this.createHttpProvider(e,t);s&&(this.httpProviders[e]=s)}createHttpProvider(e,t){const s=t||r(e,this.namespace);return typeof s>\"u\"?void 0:new a(new h(s))}}const p=\"error\",S=\"wss://relay.walletconnect.com\",A=\"wc\",D=\"universal_provider\",d=`${A}@${2}:${D}:`;var _=Object.defineProperty,k=Object.defineProperties,j=Object.getOwnPropertyDescriptors,l=Object.getOwnPropertySymbols,R=Object.prototype.hasOwnProperty,L=Object.prototype.propertyIsEnumerable,u=(i,e,t)=>e in i?_(i,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):i[e]=t,v=(i,e)=>{for(var t in e||(e={}))R.call(e,t)&&u(i,t,e[t]);if(l)for(var t of l(e))L.call(e,t)&&u(i,t,e[t]);return i},U=(i,e)=>k(i,j(e));class c{constructor(e){this.events=new y,this.rpcProviders={},this.providerOpts=e,this.logger=typeof e?.logger<\"u\"&&typeof e?.logger!=\"string\"?e.logger:f(C({level:e?.logger||p}))}static async init(e){const t=new c(e);return await t.initialize(),t}async request(e,t){const[s,n]=this.validateChain(t);if(!this.session)throw new Error(\"Please call connect() before request()\");return await this.getProvider(s).request({request:v({},e),chainId:`${s}:${n}`,topic:this.session.topic})}sendAsync(e,t,s){this.request(e,s).then(n=>t(null,n)).catch(n=>t(n,void 0))}async enable(){if(!this.client)throw new Error(\"Sign Client not initialized\");return this.session||await this.connect({namespaces:this.namespaces,optionalNamespaces:this.optionalNamespaces,sessionProperties:this.sessionProperties}),await this.requestAccounts()}async disconnect(){var e;if(!this.session)throw new Error(\"Please call connect() before enable()\");await this.client.disconnect({topic:(e=this.session)==null?void 0:e.topic,reason:P(\"USER_DISCONNECTED\")}),await this.cleanup()}async connect(e){if(!this.client)throw new Error(\"Sign Client not initialized\");if(this.setNamespaces(e),await this.cleanupPendingPairings(),this.createProviders(),!e.skipPairing)return await this.pair(e.pairingTopic)}on(e,t){this.events.on(e,t)}once(e,t){this.events.once(e,t)}removeListener(e,t){this.events.removeListener(e,t)}off(e,t){this.events.off(e,t)}get isWalletConnect(){return!0}async pair(e){const{uri:t,approval:s}=await this.client.connect({pairingTopic:e,requiredNamespaces:this.namespaces,optionalNamespaces:this.optionalNamespaces,sessionProperties:this.sessionProperties});return t&&(this.uri=t,this.events.emit(\"display_uri\",t)),this.session=await s(),this.onSessionUpdate(),this.onConnect(),this.session}setDefaultChain(e,t){try{const[s,n]=this.validateChain(e);this.getProvider(s).setDefaultChain(n,t)}catch(s){if(!/Please call connect/.test(s.message))throw s}}async cleanupPendingPairings(e={}){this.logger.info(\"Cleaning up inactive pairings...\");const t=this.client.pairing.getAll();if(w(t)){for(const s of t)e.deletePairings?this.client.core.expirer.set(s.topic,0):await this.client.core.relayer.subscriber.unsubscribe(s.topic);this.logger.info(`Inactive pairings cleared: ${t.length}`)}}async checkStorage(){if(this.namespaces=await this.client.core.storage.getItem(`${d}/namespaces`)||{},this.namespaces&&this.createProviders(),this.client.session.length){const e=this.client.session.keys.length-1;this.session=this.client.session.get(this.client.session.keys[e]),this.onSessionUpdate()}}async initialize(){this.logger.trace(\"Initialized\"),await this.createClient(),this.checkStorage(),this.registerEventListeners()}async createClient(){this.client=this.providerOpts.client||await g.init({logger:this.providerOpts.logger||p,relayUrl:this.providerOpts.relayUrl||S,projectId:this.providerOpts.projectId,metadata:this.providerOpts.metadata,storageOptions:this.providerOpts.storageOptions,name:this.providerOpts.name}),this.logger.trace(\"SignClient Initialized\")}createProviders(){if(!this.client)throw new Error(\"Sign Client not initialized\");Object.keys(this.namespaces).forEach(e=>{var t;const s=Object.assign({},this.namespaces[e],(t=this.optionalNamespaces)==null?void 0:t[e]);switch(e){case\"eip155\":this.rpcProviders[e]=new H({client:this.client,namespace:s,events:this.events});break;case\"solana\":this.rpcProviders[e]=new $({client:this.client,namespace:s,events:this.events});break;case\"cosmos\":this.rpcProviders[e]=new b({client:this.client,namespace:s,events:this.events});break;case\"polkadot\":break;case\"cip34\":this.rpcProviders[e]=new N({client:this.client,namespace:s,events:this.events});break}})}registerEventListeners(){if(typeof this.client>\"u\")throw new Error(\"Sign Client is not initialized\");this.client.on(\"session_ping\",e=>{this.events.emit(\"session_ping\",e)}),this.client.on(\"session_event\",e=>{const{params:t}=e,{event:s}=t;s.name===\"accountsChanged\"?this.events.emit(\"accountsChanged\",s.data):s.name===\"chainChanged\"?this.onChainChanged(s.data,t.chainId):this.events.emit(s.name,s.data),this.events.emit(\"session_event\",e)}),this.client.on(\"session_update\",({topic:e,params:t})=>{var s;const{namespaces:n}=t,m=(s=this.client)==null?void 0:s.session.get(e);this.session=U(v({},m),{namespaces:n}),this.onSessionUpdate(),this.events.emit(\"session_update\",{topic:e,params:t})}),this.client.on(\"session_delete\",async e=>{await this.cleanup(),this.events.emit(\"session_delete\",e)})}getProvider(e){if(!this.rpcProviders[e])throw new Error(`Provider not found: ${e}`);return this.rpcProviders[e]}onSessionUpdate(){Object.keys(this.rpcProviders).forEach(e=>{var t;this.getProvider(e).updateNamespace((t=this.session)==null?void 0:t.namespaces[e])})}setNamespaces(e){const{namespaces:t,optionalNamespaces:s,sessionProperties:n}=e;if(!t||!Object.keys(t).length)throw new Error(\"Namespaces must be not empty\");this.client.core.storage.setItem(`${d}/namespaces`,t),this.namespaces=t,this.optionalNamespaces=s,this.sessionProperties=n}validateChain(e){const[t,s]=e?.split(\":\")||[\"\",\"\"];if(t&&!Object.keys(this.namespaces).includes(t))throw new Error(`Namespace '${t}' is not configured. Please call connect() first with namespace config.`);return!t||!s?E(this.namespaces):[t,s]}async requestAccounts(){const[e]=this.validateChain();return await this.getProvider(e).requestAccounts()}onChainChanged(e,t){const[s,n]=this.validateChain(t);this.getProvider(s).setDefaultChain(n),this.events.emit(\"chainChanged\",e)}onConnect(){this.events.emit(\"connect\",{session:this.session})}async cleanup(){this.session=void 0,await this.cleanupPendingPairings({deletePairings:!0})}}const T=c;export{T as UniversalProvider,c as default};\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}