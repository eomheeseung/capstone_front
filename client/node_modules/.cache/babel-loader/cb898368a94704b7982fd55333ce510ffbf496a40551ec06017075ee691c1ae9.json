{"ast":null,"code":"import _regeneratorRuntime from \"C:/Users/paete/Prototype/nftmusicProtoCopy/client/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nimport _asyncToGenerator from \"C:/Users/paete/Prototype/nftmusicProtoCopy/client/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport _createForOfIteratorHelper from \"C:/Users/paete/Prototype/nftmusicProtoCopy/client/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport _toConsumableArray from \"C:/Users/paete/Prototype/nftmusicProtoCopy/client/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\nimport _slicedToArray from \"C:/Users/paete/Prototype/nftmusicProtoCopy/client/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport { ChaCha20Poly1305 as Y } from \"@stablelib/chacha20poly1305\";\nimport { HKDF as Be } from \"@stablelib/hkdf\";\nimport { randomBytes as W } from \"@stablelib/random\";\nimport { SHA256 as Ge, hash as J } from \"@stablelib/sha256\";\nimport * as Q from \"@stablelib/x25519\";\nimport { toString as d, fromString as l, concat as Z } from \"uint8arrays\";\nimport { detect as ze } from \"detect-browser\";\nimport { fromMiliseconds as X, toMiliseconds as D, FIVE_MINUTES as Ye } from \"@walletconnect/time\";\nimport { getDocument as We, getNavigator as ee, getLocation as ne } from \"@walletconnect/window-getters\";\nimport { getWindowMetadata as Je } from \"@walletconnect/window-metadata\";\nimport * as T from \"query-string\";\nimport { RELAY_JSONRPC as Qe } from \"@walletconnect/relay-api\";\nvar P = \":\";\nfunction te(e) {\n  var _e$split = e.split(P),\n    _e$split2 = _slicedToArray(_e$split, 2),\n    n = _e$split2[0],\n    t = _e$split2[1];\n  return {\n    namespace: n,\n    reference: t\n  };\n}\nfunction re(e) {\n  var n = e.namespace,\n    t = e.reference;\n  return [n, t].join(P);\n}\nfunction $(e) {\n  var _e$split3 = e.split(P),\n    _e$split4 = _slicedToArray(_e$split3, 3),\n    n = _e$split4[0],\n    t = _e$split4[1],\n    r = _e$split4[2];\n  return {\n    namespace: n,\n    reference: t,\n    address: r\n  };\n}\nfunction oe(e) {\n  var n = e.namespace,\n    t = e.reference,\n    r = e.address;\n  return [n, t, r].join(P);\n}\nfunction j(e, n) {\n  var t = [];\n  return e.forEach(function (r) {\n    var o = n(r);\n    t.includes(o) || t.push(o);\n  }), t;\n}\nfunction se(e) {\n  var _$ = $(e),\n    n = _$.address;\n  return n;\n}\nfunction ie(e) {\n  var _$2 = $(e),\n    n = _$2.namespace,\n    t = _$2.reference;\n  return re({\n    namespace: n,\n    reference: t\n  });\n}\nfunction Ze(e, n) {\n  var _te = te(n),\n    t = _te.namespace,\n    r = _te.reference;\n  return oe({\n    namespace: t,\n    reference: r,\n    address: e\n  });\n}\nfunction Xe(e) {\n  return j(e, se);\n}\nfunction ce(e) {\n  return j(e, ie);\n}\nfunction en(e) {\n  var n = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n  var t = [];\n  return Object.keys(e).forEach(function (r) {\n    if (n.length && !n.includes(r)) return;\n    var o = e[r];\n    t.push.apply(t, _toConsumableArray(o.accounts));\n  }), t;\n}\nfunction nn(e) {\n  var n = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n  var t = [];\n  return Object.keys(e).forEach(function (r) {\n    if (n.length && !n.includes(r)) return;\n    var o = e[r];\n    t.push.apply(t, _toConsumableArray(ce(o.accounts)));\n  }), t;\n}\nfunction tn(e) {\n  var n = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n  var t = [];\n  return Object.keys(e).forEach(function (r) {\n    if (n.length && !n.includes(r)) return;\n    var o = e[r];\n    t.push.apply(t, _toConsumableArray(o.chains));\n  }), t;\n}\nvar U = function U(e) {\n    return e === null || e === void 0 ? void 0 : e.split(\":\");\n  },\n  ae = function ae(e) {\n    var n = e && U(e);\n    if (n) return n[3];\n  },\n  rn = function rn(e) {\n    var n = e && U(e);\n    if (n) return n[2] + \":\" + n[3];\n  },\n  ue = function ue(e) {\n    var n = e && U(e);\n    if (n) return n.pop();\n  },\n  on = function on(e, n) {\n    var t = \"\".concat(e.domain, \" wants you to sign in with your Ethereum account:\"),\n      r = ue(n),\n      o = e.statement,\n      s = \"URI: \".concat(e.aud),\n      i = \"Version: \".concat(e.version),\n      u = \"Chain ID: \".concat(ae(n)),\n      f = \"Nonce: \".concat(e.nonce),\n      g = \"Issued At: \".concat(e.iat),\n      O = e.resources && e.resources.length > 0 ? \"Resources:\\n\".concat(e.resources.map(function (p) {\n        return \"- \".concat(p);\n      }).join(\"\\n\")) : void 0;\n    return [t, r, \"\", o, \"\", s, i, u, f, g, O].filter(function (p) {\n      return p != null;\n    }).join(\"\\n\");\n  },\n  V = \"base10\",\n  c = \"base16\",\n  R = \"base64pad\",\n  _ = \"utf8\",\n  M = 0,\n  N = 1,\n  sn = 0,\n  de = 1,\n  K = 12,\n  k = 32;\nfunction cn() {\n  var e = Q.generateKeyPair();\n  return {\n    privateKey: d(e.secretKey, c),\n    publicKey: d(e.publicKey, c)\n  };\n}\nfunction an() {\n  var e = W(k);\n  return d(e, c);\n}\nfunction un(e, n) {\n  var t = Q.sharedKey(l(e, c), l(n, c)),\n    r = new Be(Ge, t).expand(k);\n  return d(r, c);\n}\nfunction dn(e) {\n  var n = J(l(e, c));\n  return d(n, c);\n}\nfunction ln(e) {\n  var n = J(l(e, _));\n  return d(n, c);\n}\nfunction le(e) {\n  return l(\"\".concat(e), V);\n}\nfunction S(e) {\n  return Number(d(e, V));\n}\nfunction fn(e) {\n  var n = le(typeof e.type < \"u\" ? e.type : M);\n  if (S(n) === N && typeof e.senderPublicKey > \"u\") throw new Error(\"Missing sender public key for type 1 envelope\");\n  var t = typeof e.senderPublicKey < \"u\" ? l(e.senderPublicKey, c) : void 0,\n    r = typeof e.iv < \"u\" ? l(e.iv, c) : W(K),\n    o = new Y(l(e.symKey, c)).seal(r, l(e.message, _));\n  return fe({\n    type: n,\n    sealed: o,\n    iv: r,\n    senderPublicKey: t\n  });\n}\nfunction pn(e) {\n  var n = new Y(l(e.symKey, c)),\n    _L = L(e.encoded),\n    t = _L.sealed,\n    r = _L.iv,\n    o = n.open(r, t);\n  if (o === null) throw new Error(\"Failed to decrypt\");\n  return d(o, _);\n}\nfunction fe(e) {\n  if (S(e.type) === N) {\n    if (typeof e.senderPublicKey > \"u\") throw new Error(\"Missing sender public key for type 1 envelope\");\n    return d(Z([e.type, e.senderPublicKey, e.iv, e.sealed]), R);\n  }\n  return d(Z([e.type, e.iv, e.sealed]), R);\n}\nfunction L(e) {\n  var n = l(e, R),\n    t = n.slice(sn, de),\n    r = de;\n  if (S(t) === N) {\n    var u = r + k,\n      f = u + K,\n      g = n.slice(r, u),\n      O = n.slice(u, f),\n      p = n.slice(f);\n    return {\n      type: t,\n      sealed: p,\n      iv: O,\n      senderPublicKey: g\n    };\n  }\n  var o = r + K,\n    s = n.slice(r, o),\n    i = n.slice(o);\n  return {\n    type: t,\n    sealed: i,\n    iv: s\n  };\n}\nfunction mn(e, n) {\n  var t = L(e);\n  return pe({\n    type: S(t.type),\n    senderPublicKey: typeof t.senderPublicKey < \"u\" ? d(t.senderPublicKey, c) : void 0,\n    receiverPublicKey: n === null || n === void 0 ? void 0 : n.receiverPublicKey\n  });\n}\nfunction pe(e) {\n  var n = (e === null || e === void 0 ? void 0 : e.type) || M;\n  if (n === N) {\n    if (typeof (e === null || e === void 0 ? void 0 : e.senderPublicKey) > \"u\") throw new Error(\"missing sender public key\");\n    if (typeof (e === null || e === void 0 ? void 0 : e.receiverPublicKey) > \"u\") throw new Error(\"missing receiver public key\");\n  }\n  return {\n    type: n,\n    senderPublicKey: e === null || e === void 0 ? void 0 : e.senderPublicKey,\n    receiverPublicKey: e === null || e === void 0 ? void 0 : e.receiverPublicKey\n  };\n}\nfunction yn(e) {\n  return e.type === N && typeof e.senderPublicKey == \"string\" && typeof e.receiverPublicKey == \"string\";\n}\nvar En = Object.defineProperty,\n  me = Object.getOwnPropertySymbols,\n  gn = Object.prototype.hasOwnProperty,\n  hn = Object.prototype.propertyIsEnumerable,\n  ye = function ye(e, n, t) {\n    return n in e ? En(e, n, {\n      enumerable: !0,\n      configurable: !0,\n      writable: !0,\n      value: t\n    }) : e[n] = t;\n  },\n  Ee = function Ee(e, n) {\n    for (var t in n || (n = {})) gn.call(n, t) && ye(e, t, n[t]);\n    if (me) {\n      var _iterator = _createForOfIteratorHelper(me(n)),\n        _step;\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var t = _step.value;\n          hn.call(n, t) && ye(e, t, n[t]);\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n    }\n    return e;\n  };\nvar ge = \"ReactNative\",\n  v = {\n    reactNative: \"react-native\",\n    node: \"node\",\n    browser: \"browser\",\n    unknown: \"unknown\"\n  },\n  A = \" \",\n  Nn = \":\",\n  he = \"/\",\n  x = 2,\n  vn = 1e3,\n  Ne = \"js\";\nfunction F() {\n  return typeof process < \"u\" && typeof process.versions < \"u\" && typeof process.versions.node < \"u\";\n}\nfunction ve() {\n  return !We() && !!ee() && navigator.product === ge;\n}\nfunction be() {\n  return !F() && !!ee();\n}\nfunction H() {\n  return ve() ? v.reactNative : F() ? v.node : be() ? v.browser : v.unknown;\n}\nfunction Oe(e, n) {\n  var t = T.parse(e);\n  return t = Ee(Ee({}, t), n), e = T.stringify(t), e;\n}\nfunction bn() {\n  return Je() || {\n    name: \"\",\n    description: \"\",\n    url: \"\",\n    icons: [\"\"]\n  };\n}\nfunction On(e, n) {\n  var t;\n  var r = H(),\n    o = {\n      protocol: e,\n      version: n,\n      env: r\n    };\n  return r === \"browser\" && (o.host = ((t = ne()) == null ? void 0 : t.host) || \"unknown\"), o;\n}\nfunction Se() {\n  var e = ze();\n  if (e === null) return \"unknown\";\n  var n = e.os ? e.os.replace(\" \", \"\").toLowerCase() : \"unknown\";\n  return e.type === \"browser\" ? [n, e.name, e.version].join(\"-\") : [n, e.version].join(\"-\");\n}\nfunction Ie() {\n  var e;\n  var n = H();\n  return n === v.browser ? [n, ((e = ne()) == null ? void 0 : e.host) || \"unknown\"].join(\":\") : n;\n}\nfunction Te(e, n, t) {\n  var r = Se(),\n    o = Ie();\n  return [[e, n].join(\"-\"), [Ne, t].join(\"-\"), r, o].join(\"/\");\n}\nfunction Sn(_ref) {\n  var e = _ref.protocol,\n    n = _ref.version,\n    t = _ref.relayUrl,\n    r = _ref.sdkVersion,\n    o = _ref.auth,\n    s = _ref.projectId;\n  var i = t.split(\"?\"),\n    u = Te(e, n, r),\n    f = {\n      auth: o,\n      ua: u,\n      projectId: s\n    },\n    g = Oe(i[1] || \"\", f);\n  return i[0] + \"?\" + g;\n}\nfunction In(e) {\n  var n = (e.match(/^[^:]+(?=:\\/\\/)/gi) || [])[0];\n  var t = typeof n < \"u\" ? e.split(\"://\")[1] : e;\n  return n = n === \"wss\" ? \"https\" : \"http\", [n, t].join(\"://\");\n}\nfunction Tn(e, n, t) {\n  if (!e[n] || typeof e[n] !== t) throw new Error(\"Missing or invalid \\\"\".concat(n, \"\\\" param\"));\n}\nfunction Pe(e) {\n  var n = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : x;\n  return Ue(e.split(he), n);\n}\nfunction Pn(e) {\n  return Pe(e).join(A);\n}\nfunction m(e, n) {\n  return e.filter(function (t) {\n    return n.includes(t);\n  }).length === e.length;\n}\nfunction Ue(e) {\n  var n = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : x;\n  return e.slice(Math.max(e.length - n, 0));\n}\nfunction Un(e) {\n  return Object.fromEntries(e.entries());\n}\nfunction Rn(e) {\n  return new Map(Object.entries(e));\n}\nfunction _n(e, n) {\n  var t = {};\n  return Object.keys(e).forEach(function (r) {\n    t[r] = n(e[r]);\n  }), t;\n}\nvar An = function An(e) {\n  return e;\n};\nfunction Re(e) {\n  return e.trim().replace(/^\\w/, function (n) {\n    return n.toUpperCase();\n  });\n}\nfunction wn(e) {\n  return e.split(A).map(function (n) {\n    return Re(n);\n  }).join(A);\n}\nfunction Cn(e, n) {\n  return X((n || Date.now()) + D(e));\n}\nfunction Dn(e) {\n  return X(Date.now()) >= D(e);\n}\nfunction $n(e) {\n  var n = D(e || Ye);\n  var t, r, o;\n  return {\n    resolve: function resolve(s) {\n      o && t && (clearTimeout(o), t(s));\n    },\n    reject: function reject(s) {\n      o && r && (clearTimeout(o), r(s));\n    },\n    done: function done() {\n      return new Promise(function (s, i) {\n        o = setTimeout(i, n), t = s, r = i;\n      });\n    }\n  };\n}\nfunction jn(e, n) {\n  return new Promise( /*#__PURE__*/function () {\n    var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(t, r) {\n      var o, s;\n      return _regeneratorRuntime().wrap(function _callee$(_context) {\n        while (1) switch (_context.prev = _context.next) {\n          case 0:\n            o = setTimeout(function () {\n              return r();\n            }, n);\n            _context.next = 3;\n            return e;\n          case 3:\n            s = _context.sent;\n            clearTimeout(o), t(s);\n          case 5:\n          case \"end\":\n            return _context.stop();\n        }\n      }, _callee);\n    }));\n    return function (_x, _x2) {\n      return _ref2.apply(this, arguments);\n    };\n  }());\n}\nfunction q(e, n) {\n  if (typeof n == \"string\" && n.startsWith(\"\".concat(e, \":\"))) return n;\n  if (e.toLowerCase() === \"topic\") {\n    if (typeof n != \"string\") throw new Error('Value must be \"string\" for expirer target type: topic');\n    return \"topic:\".concat(n);\n  } else if (e.toLowerCase() === \"id\") {\n    if (typeof n != \"number\") throw new Error('Value must be \"number\" for expirer target type: id');\n    return \"id:\".concat(n);\n  }\n  throw new Error(\"Unknown expirer target type: \".concat(e));\n}\nfunction Vn(e) {\n  return q(\"topic\", e);\n}\nfunction Mn(e) {\n  return q(\"id\", e);\n}\nfunction Kn(e) {\n  var _e$split5 = e.split(\":\"),\n    _e$split6 = _slicedToArray(_e$split5, 2),\n    n = _e$split6[0],\n    t = _e$split6[1],\n    r = {\n      id: void 0,\n      topic: void 0\n    };\n  if (n === \"topic\" && typeof t == \"string\") r.topic = t;else if (n === \"id\" && Number.isInteger(Number(t))) r.id = Number(t);else throw new Error(\"Invalid target, expected id:number or topic:string, got \".concat(n, \":\").concat(t));\n  return r;\n}\nfunction kn(e, n) {\n  return \"\".concat(e).concat(n ? \":\".concat(n) : \"\");\n}\nvar _e = \"irn\";\nfunction Ln(e) {\n  return (e === null || e === void 0 ? void 0 : e.relay) || {\n    protocol: _e\n  };\n}\nfunction xn(e) {\n  var n = Qe[e];\n  if (typeof n > \"u\") throw new Error(\"Relay Protocol not supported: \".concat(e));\n  return n;\n}\nvar Fn = Object.defineProperty,\n  Ae = Object.getOwnPropertySymbols,\n  Hn = Object.prototype.hasOwnProperty,\n  qn = Object.prototype.propertyIsEnumerable,\n  we = function we(e, n, t) {\n    return n in e ? Fn(e, n, {\n      enumerable: !0,\n      configurable: !0,\n      writable: !0,\n      value: t\n    }) : e[n] = t;\n  },\n  Bn = function Bn(e, n) {\n    for (var t in n || (n = {})) Hn.call(n, t) && we(e, t, n[t]);\n    if (Ae) {\n      var _iterator2 = _createForOfIteratorHelper(Ae(n)),\n        _step2;\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var t = _step2.value;\n          qn.call(n, t) && we(e, t, n[t]);\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n    }\n    return e;\n  };\nfunction Ce(e) {\n  var n = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"-\";\n  var t = {},\n    r = \"relay\" + n;\n  return Object.keys(e).forEach(function (o) {\n    if (o.startsWith(r)) {\n      var s = o.replace(r, \"\"),\n        i = e[o];\n      t[s] = i;\n    }\n  }), t;\n}\nfunction Gn(e) {\n  var n = e.indexOf(\":\"),\n    t = e.indexOf(\"?\") !== -1 ? e.indexOf(\"?\") : void 0,\n    r = e.substring(0, n),\n    o = e.substring(n + 1, t).split(\"@\"),\n    s = typeof t < \"u\" ? e.substring(t) : \"\",\n    i = T.parse(s);\n  return {\n    protocol: r,\n    topic: o[0],\n    version: parseInt(o[1], 10),\n    symKey: i.symKey,\n    relay: Ce(i)\n  };\n}\nfunction De(e) {\n  var n = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"-\";\n  var t = \"relay\",\n    r = {};\n  return Object.keys(e).forEach(function (o) {\n    var s = t + n + o;\n    e[o] && (r[s] = e[o]);\n  }), r;\n}\nfunction zn(e) {\n  return \"\".concat(e.protocol, \":\").concat(e.topic, \"@\").concat(e.version, \"?\") + T.stringify(Bn({\n    symKey: e.symKey\n  }, De(e.relay)));\n}\nfunction b(e) {\n  var n = [];\n  return e.forEach(function (t) {\n    var _t$split = t.split(\":\"),\n      _t$split2 = _slicedToArray(_t$split, 2),\n      r = _t$split2[0],\n      o = _t$split2[1];\n    n.push(\"\".concat(r, \":\").concat(o));\n  }), n;\n}\nfunction $e(e) {\n  var n = [];\n  return Object.values(e).forEach(function (t) {\n    n.push.apply(n, _toConsumableArray(b(t.accounts)));\n  }), n;\n}\nfunction je(e, n) {\n  var t = [];\n  return Object.values(e).forEach(function (r) {\n    b(r.accounts).includes(n) && t.push.apply(t, _toConsumableArray(r.methods));\n  }), t;\n}\nfunction Ve(e, n) {\n  var t = [];\n  return Object.values(e).forEach(function (r) {\n    b(r.accounts).includes(n) && t.push.apply(t, _toConsumableArray(r.events));\n  }), t;\n}\nfunction Yn(e, n) {\n  var t = He(e, n);\n  if (t) throw new Error(t.message);\n  var r = {};\n  for (var _i = 0, _Object$entries = Object.entries(e); _i < _Object$entries.length; _i++) {\n    var _Object$entries$_i = _slicedToArray(_Object$entries[_i], 2),\n      o = _Object$entries$_i[0],\n      s = _Object$entries$_i[1];\n    r[o] = {\n      methods: s.methods,\n      events: s.events,\n      chains: s.accounts.map(function (i) {\n        return \"\".concat(i.split(\":\")[0], \":\").concat(i.split(\":\")[1]);\n      })\n    };\n  }\n  return r;\n}\nvar Wn = {\n    INVALID_METHOD: {\n      message: \"Invalid method.\",\n      code: 1001\n    },\n    INVALID_EVENT: {\n      message: \"Invalid event.\",\n      code: 1002\n    },\n    INVALID_UPDATE_REQUEST: {\n      message: \"Invalid update request.\",\n      code: 1003\n    },\n    INVALID_EXTEND_REQUEST: {\n      message: \"Invalid extend request.\",\n      code: 1004\n    },\n    INVALID_SESSION_SETTLE_REQUEST: {\n      message: \"Invalid session settle request.\",\n      code: 1005\n    },\n    UNAUTHORIZED_METHOD: {\n      message: \"Unauthorized method.\",\n      code: 3001\n    },\n    UNAUTHORIZED_EVENT: {\n      message: \"Unauthorized event.\",\n      code: 3002\n    },\n    UNAUTHORIZED_UPDATE_REQUEST: {\n      message: \"Unauthorized update request.\",\n      code: 3003\n    },\n    UNAUTHORIZED_EXTEND_REQUEST: {\n      message: \"Unauthorized extend request.\",\n      code: 3004\n    },\n    USER_REJECTED: {\n      message: \"User rejected.\",\n      code: 5e3\n    },\n    USER_REJECTED_CHAINS: {\n      message: \"User rejected chains.\",\n      code: 5001\n    },\n    USER_REJECTED_METHODS: {\n      message: \"User rejected methods.\",\n      code: 5002\n    },\n    USER_REJECTED_EVENTS: {\n      message: \"User rejected events.\",\n      code: 5003\n    },\n    UNSUPPORTED_CHAINS: {\n      message: \"Unsupported chains.\",\n      code: 5100\n    },\n    UNSUPPORTED_METHODS: {\n      message: \"Unsupported methods.\",\n      code: 5101\n    },\n    UNSUPPORTED_EVENTS: {\n      message: \"Unsupported events.\",\n      code: 5102\n    },\n    UNSUPPORTED_ACCOUNTS: {\n      message: \"Unsupported accounts.\",\n      code: 5103\n    },\n    UNSUPPORTED_NAMESPACE_KEY: {\n      message: \"Unsupported namespace key.\",\n      code: 5104\n    },\n    USER_DISCONNECTED: {\n      message: \"User disconnected.\",\n      code: 6e3\n    },\n    SESSION_SETTLEMENT_FAILED: {\n      message: \"Session settlement failed.\",\n      code: 7e3\n    },\n    WC_METHOD_UNSUPPORTED: {\n      message: \"Unsupported wc_ method.\",\n      code: 10001\n    }\n  },\n  Jn = {\n    NOT_INITIALIZED: {\n      message: \"Not initialized.\",\n      code: 1\n    },\n    NO_MATCHING_KEY: {\n      message: \"No matching key.\",\n      code: 2\n    },\n    RESTORE_WILL_OVERRIDE: {\n      message: \"Restore will override.\",\n      code: 3\n    },\n    RESUBSCRIBED: {\n      message: \"Resubscribed.\",\n      code: 4\n    },\n    MISSING_OR_INVALID: {\n      message: \"Missing or invalid.\",\n      code: 5\n    },\n    EXPIRED: {\n      message: \"Expired.\",\n      code: 6\n    },\n    UNKNOWN_TYPE: {\n      message: \"Unknown type.\",\n      code: 7\n    },\n    MISMATCHED_TOPIC: {\n      message: \"Mismatched topic.\",\n      code: 8\n    },\n    NON_CONFORMING_NAMESPACES: {\n      message: \"Non conforming namespaces.\",\n      code: 9\n    }\n  };\nfunction y(e, n) {\n  var _Jn$e = Jn[e],\n    t = _Jn$e.message,\n    r = _Jn$e.code;\n  return {\n    message: n ? \"\".concat(t, \" \").concat(n) : t,\n    code: r\n  };\n}\nfunction h(e, n) {\n  var _Wn$e = Wn[e],\n    t = _Wn$e.message,\n    r = _Wn$e.code;\n  return {\n    message: n ? \"\".concat(t, \" \").concat(n) : t,\n    code: r\n  };\n}\nfunction I(e, n) {\n  return Array.isArray(e) ? typeof n < \"u\" && e.length ? e.every(n) : !0 : !1;\n}\nfunction B(e) {\n  return Object.getPrototypeOf(e) === Object.prototype && Object.keys(e).length;\n}\nfunction E(e) {\n  return typeof e > \"u\";\n}\nfunction a(e, n) {\n  return n && E(e) ? !0 : typeof e == \"string\" && Boolean(e.trim().length);\n}\nfunction w(e, n) {\n  return n && E(e) ? !0 : typeof e == \"number\" && !isNaN(e);\n}\nfunction Qn(e, n) {\n  var t = n.requiredNamespaces,\n    r = Object.keys(e.namespaces),\n    o = Object.keys(t);\n  var s = !0;\n  return m(o, r) ? (r.forEach(function (i) {\n    var _e$namespaces$i = e.namespaces[i],\n      u = _e$namespaces$i.accounts,\n      f = _e$namespaces$i.methods,\n      g = _e$namespaces$i.events,\n      O = b(u),\n      p = t[i];\n    (!m(p.chains, O) || !m(p.methods, f) || !m(p.events, g)) && (s = !1);\n  }), s) : !1;\n}\nfunction C(e) {\n  return a(e, !1) && e.includes(\":\") ? e.split(\":\").length === 2 : !1;\n}\nfunction Me(e) {\n  if (a(e, !1) && e.includes(\":\")) {\n    var n = e.split(\":\");\n    if (n.length === 3) {\n      var t = n[0] + \":\" + n[1];\n      return !!n[2] && C(t);\n    }\n  }\n  return !1;\n}\nfunction Zn(e) {\n  if (a(e, !1)) try {\n    return typeof new URL(e) < \"u\";\n  } catch (_unused) {\n    return !1;\n  }\n  return !1;\n}\nfunction Xn(e) {\n  var n;\n  return (n = e === null || e === void 0 ? void 0 : e.proposer) == null ? void 0 : n.publicKey;\n}\nfunction et(e) {\n  return e === null || e === void 0 ? void 0 : e.topic;\n}\nfunction nt(e, n) {\n  var t = null;\n  return a(e === null || e === void 0 ? void 0 : e.publicKey, !1) || (t = y(\"MISSING_OR_INVALID\", \"\".concat(n, \" controller public key should be a string\"))), t;\n}\nfunction G(e) {\n  var n = !0;\n  return I(e) ? e.length && (n = e.every(function (t) {\n    return a(t, !1);\n  })) : n = !1, n;\n}\nfunction Ke(e, n, t) {\n  var r = null;\n  return I(n) ? n.forEach(function (o) {\n    r || (!C(o) || !o.includes(e)) && (r = h(\"UNSUPPORTED_CHAINS\", \"\".concat(t, \", chain \").concat(o, \" should be a string and conform to \\\"namespace:chainId\\\" format\")));\n  }) : r = h(\"UNSUPPORTED_CHAINS\", \"\".concat(t, \", chains \").concat(n, \" should be an array of strings conforming to \\\"namespace:chainId\\\" format\")), r;\n}\nfunction ke(e, n) {\n  var t = null;\n  return Object.entries(e).forEach(function (_ref3) {\n    var _ref4 = _slicedToArray(_ref3, 2),\n      r = _ref4[0],\n      o = _ref4[1];\n    if (t) return;\n    var s = Ke(r, o === null || o === void 0 ? void 0 : o.chains, \"\".concat(n, \" requiredNamespace\"));\n    s && (t = s);\n  }), t;\n}\nfunction Le(e, n) {\n  var t = null;\n  return I(e) ? e.forEach(function (r) {\n    t || Me(r) || (t = h(\"UNSUPPORTED_ACCOUNTS\", \"\".concat(n, \", account \").concat(r, \" should be a string and conform to \\\"namespace:chainId:address\\\" format\")));\n  }) : t = h(\"UNSUPPORTED_ACCOUNTS\", \"\".concat(n, \", accounts should be an array of strings conforming to \\\"namespace:chainId:address\\\" format\")), t;\n}\nfunction xe(e, n) {\n  var t = null;\n  return Object.values(e).forEach(function (r) {\n    if (t) return;\n    var o = Le(r === null || r === void 0 ? void 0 : r.accounts, \"\".concat(n, \" namespace\"));\n    o && (t = o);\n  }), t;\n}\nfunction Fe(e, n) {\n  var t = null;\n  return G(e === null || e === void 0 ? void 0 : e.methods) ? G(e === null || e === void 0 ? void 0 : e.events) || (t = h(\"UNSUPPORTED_EVENTS\", \"\".concat(n, \", events should be an array of strings or empty array for no events\"))) : t = h(\"UNSUPPORTED_METHODS\", \"\".concat(n, \", methods should be an array of strings or empty array for no methods\")), t;\n}\nfunction z(e, n) {\n  var t = null;\n  return Object.values(e).forEach(function (r) {\n    if (t) return;\n    var o = Fe(r, \"\".concat(n, \", namespace\"));\n    o && (t = o);\n  }), t;\n}\nfunction tt(e, n) {\n  var t = null;\n  if (e && B(e)) {\n    var r = z(e, n);\n    r && (t = r);\n    var o = ke(e, n);\n    o && (t = o);\n  } else t = y(\"MISSING_OR_INVALID\", \"\".concat(n, \", requiredNamespaces should be an object with data\"));\n  return t;\n}\nfunction He(e, n) {\n  var t = null;\n  if (e && B(e)) {\n    var r = z(e, n);\n    r && (t = r);\n    var o = xe(e, n);\n    o && (t = o);\n  } else t = y(\"MISSING_OR_INVALID\", \"\".concat(n, \", namespaces should be an object with data\"));\n  return t;\n}\nfunction qe(e) {\n  return a(e.protocol, !0);\n}\nfunction rt(e, n) {\n  var t = !1;\n  return n && !e ? t = !0 : e && I(e) && e.length && e.forEach(function (r) {\n    t = qe(r);\n  }), t;\n}\nfunction ot(e) {\n  return typeof e == \"number\";\n}\nfunction st(e) {\n  return typeof e < \"u\" && typeof e !== null;\n}\nfunction it(e) {\n  return !(!e || typeof e != \"object\" || !e.code || !w(e.code, !1) || !e.message || !a(e.message, !1));\n}\nfunction ct(e) {\n  return !(E(e) || !a(e.method, !1));\n}\nfunction at(e) {\n  return !(E(e) || E(e.result) && E(e.error) || !w(e.id, !1) || !a(e.jsonrpc, !1));\n}\nfunction ut(e) {\n  return !(E(e) || !a(e.name, !1));\n}\nfunction dt(e, n) {\n  return !(!C(n) || !$e(e).includes(n));\n}\nfunction lt(e, n, t) {\n  return a(t, !1) ? je(e, n).includes(t) : !1;\n}\nfunction ft(e, n, t) {\n  return a(t, !1) ? Ve(e, n).includes(t) : !1;\n}\nfunction pt(e, n, t) {\n  var r = null;\n  var o = Object.keys(e),\n    s = Object.keys(n);\n  return m(o, s) ? o.forEach(function (i) {\n    if (r) return;\n    var u = e[i].chains,\n      f = b(n[i].accounts);\n    m(u, f) ? m(e[i].methods, n[i].methods) ? m(e[i].events, n[i].events) || (r = y(\"NON_CONFORMING_NAMESPACES\", \"\".concat(t, \" namespaces events don't satisfy requiredNamespaces events for \").concat(i))) : r = y(\"NON_CONFORMING_NAMESPACES\", \"\".concat(t, \" namespaces methods don't satisfy requiredNamespaces methods for \").concat(i)) : r = y(\"NON_CONFORMING_NAMESPACES\", \"\".concat(t, \" namespaces accounts don't satisfy requiredNamespaces chains for \").concat(i));\n  }) : r = y(\"NON_CONFORMING_NAMESPACES\", \"\".concat(t, \" namespaces keys don't satisfy requiredNamespaces\")), r;\n}\nfunction mt(e, n) {\n  return w(e, !1) && e <= n.max && e >= n.min;\n}\nexport { V as BASE10, c as BASE16, R as BASE64, Nn as COLON, x as DEFAULT_DEPTH, A as EMPTY_SPACE, v as ENV_MAP, vn as ONE_THOUSAND, ge as REACT_NATIVE_PRODUCT, _e as RELAYER_DEFAULT_PROTOCOL, Ne as SDK_TYPE, he as SLASH, M as TYPE_0, N as TYPE_1, _ as UTF8, Oe as appendToQueryString, Tn as assertType, Cn as calcExpiry, wn as capitalize, Re as capitalizeWord, $n as createDelayedPromise, jn as createExpiringPromise, S as decodeTypeByte, pn as decrypt, un as deriveSymKey, L as deserialize, le as encodeTypeByte, fn as encrypt, kn as engineEvent, An as enumify, oe as formatAccountId, Ze as formatAccountWithChain, re as formatChainId, q as formatExpirerTarget, Mn as formatIdTarget, on as formatMessage, Pn as formatMessageContext, De as formatRelayParams, Sn as formatRelayRpcUrl, Vn as formatTopicTarget, Te as formatUA, zn as formatUri, cn as generateKeyPair, an as generateRandomBytes32, b as getAccountsChains, en as getAccountsFromNamespaces, se as getAddressFromAccount, Xe as getAddressesFromAccounts, bn as getAppMetadata, ie as getChainFromAccount, ce as getChainsFromAccounts, nn as getChainsFromNamespaces, tn as getChainsFromRequiredNamespaces, ue as getDidAddress, U as getDidAddressSegments, ae as getDidChainId, H as getEnvironment, In as getHttpUrl, y as getInternalError, Ie as getJavascriptID, Se as getJavascriptOS, Ue as getLastItems, rn as getNamespacedDidChainId, $e as getNamespacesChains, Ve as getNamespacesEventsForChainId, je as getNamespacesMethodsForChainId, On as getRelayClientMetadata, xn as getRelayProtocolApi, Ln as getRelayProtocolName, Yn as getRequiredNamespacesFromNamespaces, h as getSdkError, j as getUniqueValues, m as hasOverlap, dn as hashKey, ln as hashMessage, be as isBrowser, pt as isConformingNamespaces, Dn as isExpired, F as isNode, Xn as isProposalStruct, ve as isReactNative, Qn as isSessionCompatible, et as isSessionStruct, yn as isTypeOneEnvelope, E as isUndefined, Me as isValidAccountId, Le as isValidAccounts, Fe as isValidActions, I as isValidArray, C as isValidChainId, Ke as isValidChains, nt as isValidController, it as isValidErrorReason, ut as isValidEvent, ot as isValidId, xe as isValidNamespaceAccounts, z as isValidNamespaceActions, ke as isValidNamespaceChains, G as isValidNamespaceMethodsOrEvents, He as isValidNamespaces, dt as isValidNamespacesChainId, ft as isValidNamespacesEvent, lt as isValidNamespacesRequest, w as isValidNumber, B as isValidObject, st as isValidParams, qe as isValidRelay, rt as isValidRelays, ct as isValidRequest, mt as isValidRequestExpiry, tt as isValidRequiredNamespaces, at as isValidResponse, a as isValidString, Zn as isValidUrl, _n as mapEntries, Un as mapToObj, Rn as objToMap, $ as parseAccountId, te as parseChainId, Pe as parseContextNames, Kn as parseExpirerTarget, Ce as parseRelayParams, Gn as parseUri, fe as serialize, mn as validateDecoding, pe as validateEncoding };","map":{"version":3,"mappings":"","names":[],"sources":[],"sourcesContent":["import{ChaCha20Poly1305 as Y}from\"@stablelib/chacha20poly1305\";import{HKDF as Be}from\"@stablelib/hkdf\";import{randomBytes as W}from\"@stablelib/random\";import{SHA256 as Ge,hash as J}from\"@stablelib/sha256\";import*as Q from\"@stablelib/x25519\";import{toString as d,fromString as l,concat as Z}from\"uint8arrays\";import{detect as ze}from\"detect-browser\";import{fromMiliseconds as X,toMiliseconds as D,FIVE_MINUTES as Ye}from\"@walletconnect/time\";import{getDocument as We,getNavigator as ee,getLocation as ne}from\"@walletconnect/window-getters\";import{getWindowMetadata as Je}from\"@walletconnect/window-metadata\";import*as T from\"query-string\";import{RELAY_JSONRPC as Qe}from\"@walletconnect/relay-api\";const P=\":\";function te(e){const[n,t]=e.split(P);return{namespace:n,reference:t}}function re(e){const{namespace:n,reference:t}=e;return[n,t].join(P)}function $(e){const[n,t,r]=e.split(P);return{namespace:n,reference:t,address:r}}function oe(e){const{namespace:n,reference:t,address:r}=e;return[n,t,r].join(P)}function j(e,n){const t=[];return e.forEach(r=>{const o=n(r);t.includes(o)||t.push(o)}),t}function se(e){const{address:n}=$(e);return n}function ie(e){const{namespace:n,reference:t}=$(e);return re({namespace:n,reference:t})}function Ze(e,n){const{namespace:t,reference:r}=te(n);return oe({namespace:t,reference:r,address:e})}function Xe(e){return j(e,se)}function ce(e){return j(e,ie)}function en(e,n=[]){const t=[];return Object.keys(e).forEach(r=>{if(n.length&&!n.includes(r))return;const o=e[r];t.push(...o.accounts)}),t}function nn(e,n=[]){const t=[];return Object.keys(e).forEach(r=>{if(n.length&&!n.includes(r))return;const o=e[r];t.push(...ce(o.accounts))}),t}function tn(e,n=[]){const t=[];return Object.keys(e).forEach(r=>{if(n.length&&!n.includes(r))return;const o=e[r];t.push(...o.chains)}),t}const U=e=>e?.split(\":\"),ae=e=>{const n=e&&U(e);if(n)return n[3]},rn=e=>{const n=e&&U(e);if(n)return n[2]+\":\"+n[3]},ue=e=>{const n=e&&U(e);if(n)return n.pop()},on=(e,n)=>{const t=`${e.domain} wants you to sign in with your Ethereum account:`,r=ue(n),o=e.statement,s=`URI: ${e.aud}`,i=`Version: ${e.version}`,u=`Chain ID: ${ae(n)}`,f=`Nonce: ${e.nonce}`,g=`Issued At: ${e.iat}`,O=e.resources&&e.resources.length>0?`Resources:\n${e.resources.map(p=>`- ${p}`).join(`\n`)}`:void 0;return[t,r,\"\",o,\"\",s,i,u,f,g,O].filter(p=>p!=null).join(`\n`)},V=\"base10\",c=\"base16\",R=\"base64pad\",_=\"utf8\",M=0,N=1,sn=0,de=1,K=12,k=32;function cn(){const e=Q.generateKeyPair();return{privateKey:d(e.secretKey,c),publicKey:d(e.publicKey,c)}}function an(){const e=W(k);return d(e,c)}function un(e,n){const t=Q.sharedKey(l(e,c),l(n,c)),r=new Be(Ge,t).expand(k);return d(r,c)}function dn(e){const n=J(l(e,c));return d(n,c)}function ln(e){const n=J(l(e,_));return d(n,c)}function le(e){return l(`${e}`,V)}function S(e){return Number(d(e,V))}function fn(e){const n=le(typeof e.type<\"u\"?e.type:M);if(S(n)===N&&typeof e.senderPublicKey>\"u\")throw new Error(\"Missing sender public key for type 1 envelope\");const t=typeof e.senderPublicKey<\"u\"?l(e.senderPublicKey,c):void 0,r=typeof e.iv<\"u\"?l(e.iv,c):W(K),o=new Y(l(e.symKey,c)).seal(r,l(e.message,_));return fe({type:n,sealed:o,iv:r,senderPublicKey:t})}function pn(e){const n=new Y(l(e.symKey,c)),{sealed:t,iv:r}=L(e.encoded),o=n.open(r,t);if(o===null)throw new Error(\"Failed to decrypt\");return d(o,_)}function fe(e){if(S(e.type)===N){if(typeof e.senderPublicKey>\"u\")throw new Error(\"Missing sender public key for type 1 envelope\");return d(Z([e.type,e.senderPublicKey,e.iv,e.sealed]),R)}return d(Z([e.type,e.iv,e.sealed]),R)}function L(e){const n=l(e,R),t=n.slice(sn,de),r=de;if(S(t)===N){const u=r+k,f=u+K,g=n.slice(r,u),O=n.slice(u,f),p=n.slice(f);return{type:t,sealed:p,iv:O,senderPublicKey:g}}const o=r+K,s=n.slice(r,o),i=n.slice(o);return{type:t,sealed:i,iv:s}}function mn(e,n){const t=L(e);return pe({type:S(t.type),senderPublicKey:typeof t.senderPublicKey<\"u\"?d(t.senderPublicKey,c):void 0,receiverPublicKey:n?.receiverPublicKey})}function pe(e){const n=e?.type||M;if(n===N){if(typeof e?.senderPublicKey>\"u\")throw new Error(\"missing sender public key\");if(typeof e?.receiverPublicKey>\"u\")throw new Error(\"missing receiver public key\")}return{type:n,senderPublicKey:e?.senderPublicKey,receiverPublicKey:e?.receiverPublicKey}}function yn(e){return e.type===N&&typeof e.senderPublicKey==\"string\"&&typeof e.receiverPublicKey==\"string\"}var En=Object.defineProperty,me=Object.getOwnPropertySymbols,gn=Object.prototype.hasOwnProperty,hn=Object.prototype.propertyIsEnumerable,ye=(e,n,t)=>n in e?En(e,n,{enumerable:!0,configurable:!0,writable:!0,value:t}):e[n]=t,Ee=(e,n)=>{for(var t in n||(n={}))gn.call(n,t)&&ye(e,t,n[t]);if(me)for(var t of me(n))hn.call(n,t)&&ye(e,t,n[t]);return e};const ge=\"ReactNative\",v={reactNative:\"react-native\",node:\"node\",browser:\"browser\",unknown:\"unknown\"},A=\" \",Nn=\":\",he=\"/\",x=2,vn=1e3,Ne=\"js\";function F(){return typeof process<\"u\"&&typeof process.versions<\"u\"&&typeof process.versions.node<\"u\"}function ve(){return!We()&&!!ee()&&navigator.product===ge}function be(){return!F()&&!!ee()}function H(){return ve()?v.reactNative:F()?v.node:be()?v.browser:v.unknown}function Oe(e,n){let t=T.parse(e);return t=Ee(Ee({},t),n),e=T.stringify(t),e}function bn(){return Je()||{name:\"\",description:\"\",url:\"\",icons:[\"\"]}}function On(e,n){var t;const r=H(),o={protocol:e,version:n,env:r};return r===\"browser\"&&(o.host=((t=ne())==null?void 0:t.host)||\"unknown\"),o}function Se(){const e=ze();if(e===null)return\"unknown\";const n=e.os?e.os.replace(\" \",\"\").toLowerCase():\"unknown\";return e.type===\"browser\"?[n,e.name,e.version].join(\"-\"):[n,e.version].join(\"-\")}function Ie(){var e;const n=H();return n===v.browser?[n,((e=ne())==null?void 0:e.host)||\"unknown\"].join(\":\"):n}function Te(e,n,t){const r=Se(),o=Ie();return[[e,n].join(\"-\"),[Ne,t].join(\"-\"),r,o].join(\"/\")}function Sn({protocol:e,version:n,relayUrl:t,sdkVersion:r,auth:o,projectId:s}){const i=t.split(\"?\"),u=Te(e,n,r),f={auth:o,ua:u,projectId:s},g=Oe(i[1]||\"\",f);return i[0]+\"?\"+g}function In(e){let n=(e.match(/^[^:]+(?=:\\/\\/)/gi)||[])[0];const t=typeof n<\"u\"?e.split(\"://\")[1]:e;return n=n===\"wss\"?\"https\":\"http\",[n,t].join(\"://\")}function Tn(e,n,t){if(!e[n]||typeof e[n]!==t)throw new Error(`Missing or invalid \"${n}\" param`)}function Pe(e,n=x){return Ue(e.split(he),n)}function Pn(e){return Pe(e).join(A)}function m(e,n){return e.filter(t=>n.includes(t)).length===e.length}function Ue(e,n=x){return e.slice(Math.max(e.length-n,0))}function Un(e){return Object.fromEntries(e.entries())}function Rn(e){return new Map(Object.entries(e))}function _n(e,n){const t={};return Object.keys(e).forEach(r=>{t[r]=n(e[r])}),t}const An=e=>e;function Re(e){return e.trim().replace(/^\\w/,n=>n.toUpperCase())}function wn(e){return e.split(A).map(n=>Re(n)).join(A)}function Cn(e,n){return X((n||Date.now())+D(e))}function Dn(e){return X(Date.now())>=D(e)}function $n(e){const n=D(e||Ye);let t,r,o;return{resolve:s=>{o&&t&&(clearTimeout(o),t(s))},reject:s=>{o&&r&&(clearTimeout(o),r(s))},done:()=>new Promise((s,i)=>{o=setTimeout(i,n),t=s,r=i})}}function jn(e,n){return new Promise(async(t,r)=>{const o=setTimeout(()=>r(),n),s=await e;clearTimeout(o),t(s)})}function q(e,n){if(typeof n==\"string\"&&n.startsWith(`${e}:`))return n;if(e.toLowerCase()===\"topic\"){if(typeof n!=\"string\")throw new Error('Value must be \"string\" for expirer target type: topic');return`topic:${n}`}else if(e.toLowerCase()===\"id\"){if(typeof n!=\"number\")throw new Error('Value must be \"number\" for expirer target type: id');return`id:${n}`}throw new Error(`Unknown expirer target type: ${e}`)}function Vn(e){return q(\"topic\",e)}function Mn(e){return q(\"id\",e)}function Kn(e){const[n,t]=e.split(\":\"),r={id:void 0,topic:void 0};if(n===\"topic\"&&typeof t==\"string\")r.topic=t;else if(n===\"id\"&&Number.isInteger(Number(t)))r.id=Number(t);else throw new Error(`Invalid target, expected id:number or topic:string, got ${n}:${t}`);return r}function kn(e,n){return`${e}${n?`:${n}`:\"\"}`}const _e=\"irn\";function Ln(e){return e?.relay||{protocol:_e}}function xn(e){const n=Qe[e];if(typeof n>\"u\")throw new Error(`Relay Protocol not supported: ${e}`);return n}var Fn=Object.defineProperty,Ae=Object.getOwnPropertySymbols,Hn=Object.prototype.hasOwnProperty,qn=Object.prototype.propertyIsEnumerable,we=(e,n,t)=>n in e?Fn(e,n,{enumerable:!0,configurable:!0,writable:!0,value:t}):e[n]=t,Bn=(e,n)=>{for(var t in n||(n={}))Hn.call(n,t)&&we(e,t,n[t]);if(Ae)for(var t of Ae(n))qn.call(n,t)&&we(e,t,n[t]);return e};function Ce(e,n=\"-\"){const t={},r=\"relay\"+n;return Object.keys(e).forEach(o=>{if(o.startsWith(r)){const s=o.replace(r,\"\"),i=e[o];t[s]=i}}),t}function Gn(e){const n=e.indexOf(\":\"),t=e.indexOf(\"?\")!==-1?e.indexOf(\"?\"):void 0,r=e.substring(0,n),o=e.substring(n+1,t).split(\"@\"),s=typeof t<\"u\"?e.substring(t):\"\",i=T.parse(s);return{protocol:r,topic:o[0],version:parseInt(o[1],10),symKey:i.symKey,relay:Ce(i)}}function De(e,n=\"-\"){const t=\"relay\",r={};return Object.keys(e).forEach(o=>{const s=t+n+o;e[o]&&(r[s]=e[o])}),r}function zn(e){return`${e.protocol}:${e.topic}@${e.version}?`+T.stringify(Bn({symKey:e.symKey},De(e.relay)))}function b(e){const n=[];return e.forEach(t=>{const[r,o]=t.split(\":\");n.push(`${r}:${o}`)}),n}function $e(e){const n=[];return Object.values(e).forEach(t=>{n.push(...b(t.accounts))}),n}function je(e,n){const t=[];return Object.values(e).forEach(r=>{b(r.accounts).includes(n)&&t.push(...r.methods)}),t}function Ve(e,n){const t=[];return Object.values(e).forEach(r=>{b(r.accounts).includes(n)&&t.push(...r.events)}),t}function Yn(e,n){const t=He(e,n);if(t)throw new Error(t.message);const r={};for(const[o,s]of Object.entries(e))r[o]={methods:s.methods,events:s.events,chains:s.accounts.map(i=>`${i.split(\":\")[0]}:${i.split(\":\")[1]}`)};return r}const Wn={INVALID_METHOD:{message:\"Invalid method.\",code:1001},INVALID_EVENT:{message:\"Invalid event.\",code:1002},INVALID_UPDATE_REQUEST:{message:\"Invalid update request.\",code:1003},INVALID_EXTEND_REQUEST:{message:\"Invalid extend request.\",code:1004},INVALID_SESSION_SETTLE_REQUEST:{message:\"Invalid session settle request.\",code:1005},UNAUTHORIZED_METHOD:{message:\"Unauthorized method.\",code:3001},UNAUTHORIZED_EVENT:{message:\"Unauthorized event.\",code:3002},UNAUTHORIZED_UPDATE_REQUEST:{message:\"Unauthorized update request.\",code:3003},UNAUTHORIZED_EXTEND_REQUEST:{message:\"Unauthorized extend request.\",code:3004},USER_REJECTED:{message:\"User rejected.\",code:5e3},USER_REJECTED_CHAINS:{message:\"User rejected chains.\",code:5001},USER_REJECTED_METHODS:{message:\"User rejected methods.\",code:5002},USER_REJECTED_EVENTS:{message:\"User rejected events.\",code:5003},UNSUPPORTED_CHAINS:{message:\"Unsupported chains.\",code:5100},UNSUPPORTED_METHODS:{message:\"Unsupported methods.\",code:5101},UNSUPPORTED_EVENTS:{message:\"Unsupported events.\",code:5102},UNSUPPORTED_ACCOUNTS:{message:\"Unsupported accounts.\",code:5103},UNSUPPORTED_NAMESPACE_KEY:{message:\"Unsupported namespace key.\",code:5104},USER_DISCONNECTED:{message:\"User disconnected.\",code:6e3},SESSION_SETTLEMENT_FAILED:{message:\"Session settlement failed.\",code:7e3},WC_METHOD_UNSUPPORTED:{message:\"Unsupported wc_ method.\",code:10001}},Jn={NOT_INITIALIZED:{message:\"Not initialized.\",code:1},NO_MATCHING_KEY:{message:\"No matching key.\",code:2},RESTORE_WILL_OVERRIDE:{message:\"Restore will override.\",code:3},RESUBSCRIBED:{message:\"Resubscribed.\",code:4},MISSING_OR_INVALID:{message:\"Missing or invalid.\",code:5},EXPIRED:{message:\"Expired.\",code:6},UNKNOWN_TYPE:{message:\"Unknown type.\",code:7},MISMATCHED_TOPIC:{message:\"Mismatched topic.\",code:8},NON_CONFORMING_NAMESPACES:{message:\"Non conforming namespaces.\",code:9}};function y(e,n){const{message:t,code:r}=Jn[e];return{message:n?`${t} ${n}`:t,code:r}}function h(e,n){const{message:t,code:r}=Wn[e];return{message:n?`${t} ${n}`:t,code:r}}function I(e,n){return Array.isArray(e)?typeof n<\"u\"&&e.length?e.every(n):!0:!1}function B(e){return Object.getPrototypeOf(e)===Object.prototype&&Object.keys(e).length}function E(e){return typeof e>\"u\"}function a(e,n){return n&&E(e)?!0:typeof e==\"string\"&&Boolean(e.trim().length)}function w(e,n){return n&&E(e)?!0:typeof e==\"number\"&&!isNaN(e)}function Qn(e,n){const{requiredNamespaces:t}=n,r=Object.keys(e.namespaces),o=Object.keys(t);let s=!0;return m(o,r)?(r.forEach(i=>{const{accounts:u,methods:f,events:g}=e.namespaces[i],O=b(u),p=t[i];(!m(p.chains,O)||!m(p.methods,f)||!m(p.events,g))&&(s=!1)}),s):!1}function C(e){return a(e,!1)&&e.includes(\":\")?e.split(\":\").length===2:!1}function Me(e){if(a(e,!1)&&e.includes(\":\")){const n=e.split(\":\");if(n.length===3){const t=n[0]+\":\"+n[1];return!!n[2]&&C(t)}}return!1}function Zn(e){if(a(e,!1))try{return typeof new URL(e)<\"u\"}catch{return!1}return!1}function Xn(e){var n;return(n=e?.proposer)==null?void 0:n.publicKey}function et(e){return e?.topic}function nt(e,n){let t=null;return a(e?.publicKey,!1)||(t=y(\"MISSING_OR_INVALID\",`${n} controller public key should be a string`)),t}function G(e){let n=!0;return I(e)?e.length&&(n=e.every(t=>a(t,!1))):n=!1,n}function Ke(e,n,t){let r=null;return I(n)?n.forEach(o=>{r||(!C(o)||!o.includes(e))&&(r=h(\"UNSUPPORTED_CHAINS\",`${t}, chain ${o} should be a string and conform to \"namespace:chainId\" format`))}):r=h(\"UNSUPPORTED_CHAINS\",`${t}, chains ${n} should be an array of strings conforming to \"namespace:chainId\" format`),r}function ke(e,n){let t=null;return Object.entries(e).forEach(([r,o])=>{if(t)return;const s=Ke(r,o?.chains,`${n} requiredNamespace`);s&&(t=s)}),t}function Le(e,n){let t=null;return I(e)?e.forEach(r=>{t||Me(r)||(t=h(\"UNSUPPORTED_ACCOUNTS\",`${n}, account ${r} should be a string and conform to \"namespace:chainId:address\" format`))}):t=h(\"UNSUPPORTED_ACCOUNTS\",`${n}, accounts should be an array of strings conforming to \"namespace:chainId:address\" format`),t}function xe(e,n){let t=null;return Object.values(e).forEach(r=>{if(t)return;const o=Le(r?.accounts,`${n} namespace`);o&&(t=o)}),t}function Fe(e,n){let t=null;return G(e?.methods)?G(e?.events)||(t=h(\"UNSUPPORTED_EVENTS\",`${n}, events should be an array of strings or empty array for no events`)):t=h(\"UNSUPPORTED_METHODS\",`${n}, methods should be an array of strings or empty array for no methods`),t}function z(e,n){let t=null;return Object.values(e).forEach(r=>{if(t)return;const o=Fe(r,`${n}, namespace`);o&&(t=o)}),t}function tt(e,n){let t=null;if(e&&B(e)){const r=z(e,n);r&&(t=r);const o=ke(e,n);o&&(t=o)}else t=y(\"MISSING_OR_INVALID\",`${n}, requiredNamespaces should be an object with data`);return t}function He(e,n){let t=null;if(e&&B(e)){const r=z(e,n);r&&(t=r);const o=xe(e,n);o&&(t=o)}else t=y(\"MISSING_OR_INVALID\",`${n}, namespaces should be an object with data`);return t}function qe(e){return a(e.protocol,!0)}function rt(e,n){let t=!1;return n&&!e?t=!0:e&&I(e)&&e.length&&e.forEach(r=>{t=qe(r)}),t}function ot(e){return typeof e==\"number\"}function st(e){return typeof e<\"u\"&&typeof e!==null}function it(e){return!(!e||typeof e!=\"object\"||!e.code||!w(e.code,!1)||!e.message||!a(e.message,!1))}function ct(e){return!(E(e)||!a(e.method,!1))}function at(e){return!(E(e)||E(e.result)&&E(e.error)||!w(e.id,!1)||!a(e.jsonrpc,!1))}function ut(e){return!(E(e)||!a(e.name,!1))}function dt(e,n){return!(!C(n)||!$e(e).includes(n))}function lt(e,n,t){return a(t,!1)?je(e,n).includes(t):!1}function ft(e,n,t){return a(t,!1)?Ve(e,n).includes(t):!1}function pt(e,n,t){let r=null;const o=Object.keys(e),s=Object.keys(n);return m(o,s)?o.forEach(i=>{if(r)return;const u=e[i].chains,f=b(n[i].accounts);m(u,f)?m(e[i].methods,n[i].methods)?m(e[i].events,n[i].events)||(r=y(\"NON_CONFORMING_NAMESPACES\",`${t} namespaces events don't satisfy requiredNamespaces events for ${i}`)):r=y(\"NON_CONFORMING_NAMESPACES\",`${t} namespaces methods don't satisfy requiredNamespaces methods for ${i}`):r=y(\"NON_CONFORMING_NAMESPACES\",`${t} namespaces accounts don't satisfy requiredNamespaces chains for ${i}`)}):r=y(\"NON_CONFORMING_NAMESPACES\",`${t} namespaces keys don't satisfy requiredNamespaces`),r}function mt(e,n){return w(e,!1)&&e<=n.max&&e>=n.min}export{V as BASE10,c as BASE16,R as BASE64,Nn as COLON,x as DEFAULT_DEPTH,A as EMPTY_SPACE,v as ENV_MAP,vn as ONE_THOUSAND,ge as REACT_NATIVE_PRODUCT,_e as RELAYER_DEFAULT_PROTOCOL,Ne as SDK_TYPE,he as SLASH,M as TYPE_0,N as TYPE_1,_ as UTF8,Oe as appendToQueryString,Tn as assertType,Cn as calcExpiry,wn as capitalize,Re as capitalizeWord,$n as createDelayedPromise,jn as createExpiringPromise,S as decodeTypeByte,pn as decrypt,un as deriveSymKey,L as deserialize,le as encodeTypeByte,fn as encrypt,kn as engineEvent,An as enumify,oe as formatAccountId,Ze as formatAccountWithChain,re as formatChainId,q as formatExpirerTarget,Mn as formatIdTarget,on as formatMessage,Pn as formatMessageContext,De as formatRelayParams,Sn as formatRelayRpcUrl,Vn as formatTopicTarget,Te as formatUA,zn as formatUri,cn as generateKeyPair,an as generateRandomBytes32,b as getAccountsChains,en as getAccountsFromNamespaces,se as getAddressFromAccount,Xe as getAddressesFromAccounts,bn as getAppMetadata,ie as getChainFromAccount,ce as getChainsFromAccounts,nn as getChainsFromNamespaces,tn as getChainsFromRequiredNamespaces,ue as getDidAddress,U as getDidAddressSegments,ae as getDidChainId,H as getEnvironment,In as getHttpUrl,y as getInternalError,Ie as getJavascriptID,Se as getJavascriptOS,Ue as getLastItems,rn as getNamespacedDidChainId,$e as getNamespacesChains,Ve as getNamespacesEventsForChainId,je as getNamespacesMethodsForChainId,On as getRelayClientMetadata,xn as getRelayProtocolApi,Ln as getRelayProtocolName,Yn as getRequiredNamespacesFromNamespaces,h as getSdkError,j as getUniqueValues,m as hasOverlap,dn as hashKey,ln as hashMessage,be as isBrowser,pt as isConformingNamespaces,Dn as isExpired,F as isNode,Xn as isProposalStruct,ve as isReactNative,Qn as isSessionCompatible,et as isSessionStruct,yn as isTypeOneEnvelope,E as isUndefined,Me as isValidAccountId,Le as isValidAccounts,Fe as isValidActions,I as isValidArray,C as isValidChainId,Ke as isValidChains,nt as isValidController,it as isValidErrorReason,ut as isValidEvent,ot as isValidId,xe as isValidNamespaceAccounts,z as isValidNamespaceActions,ke as isValidNamespaceChains,G as isValidNamespaceMethodsOrEvents,He as isValidNamespaces,dt as isValidNamespacesChainId,ft as isValidNamespacesEvent,lt as isValidNamespacesRequest,w as isValidNumber,B as isValidObject,st as isValidParams,qe as isValidRelay,rt as isValidRelays,ct as isValidRequest,mt as isValidRequestExpiry,tt as isValidRequiredNamespaces,at as isValidResponse,a as isValidString,Zn as isValidUrl,_n as mapEntries,Un as mapToObj,Rn as objToMap,$ as parseAccountId,te as parseChainId,Pe as parseContextNames,Kn as parseExpirerTarget,Ce as parseRelayParams,Gn as parseUri,fe as serialize,mn as validateDecoding,pe as validateEncoding};\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}