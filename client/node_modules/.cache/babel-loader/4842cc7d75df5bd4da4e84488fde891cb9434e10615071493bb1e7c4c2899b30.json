{"ast":null,"code":"import _createForOfIteratorHelper from \"C:/Users/paete/Prototype/nftmusicProtoCopy/client/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport _classCallCheck from \"C:/Users/paete/Prototype/nftmusicProtoCopy/client/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"C:/Users/paete/Prototype/nftmusicProtoCopy/client/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport { is } from './is.js';\nimport { Token, Type } from './token.js';\nimport { Bl } from './bl.js';\nimport { encodeErrPrefix } from './common.js';\nimport { quickEncodeToken } from './jump.js';\nimport { asU8A } from './byte-utils.js';\nimport { encodeUint } from './0uint.js';\nimport { encodeNegint } from './1negint.js';\nimport { encodeBytes } from './2bytes.js';\nimport { encodeString } from './3string.js';\nimport { encodeArray } from './4array.js';\nimport { encodeMap } from './5map.js';\nimport { encodeTag } from './6tag.js';\nimport { encodeFloat } from './7float.js';\nvar defaultEncodeOptions = {\n  float64: false,\n  mapSorter: mapSorter,\n  quickEncodeToken: quickEncodeToken\n};\nexport function makeCborEncoders() {\n  var encoders = [];\n  encoders[Type.uint.major] = encodeUint;\n  encoders[Type.negint.major] = encodeNegint;\n  encoders[Type.bytes.major] = encodeBytes;\n  encoders[Type.string.major] = encodeString;\n  encoders[Type.array.major] = encodeArray;\n  encoders[Type.map.major] = encodeMap;\n  encoders[Type.tag.major] = encodeTag;\n  encoders[Type.float.major] = encodeFloat;\n  return encoders;\n}\nvar cborEncoders = makeCborEncoders();\nvar buf = new Bl();\nvar Ref = /*#__PURE__*/function () {\n  function Ref(obj, parent) {\n    _classCallCheck(this, Ref);\n    this.obj = obj;\n    this.parent = parent;\n  }\n  _createClass(Ref, [{\n    key: \"includes\",\n    value: function includes(obj) {\n      var p = this;\n      do {\n        if (p.obj === obj) {\n          return true;\n        }\n      } while (p = p.parent);\n      return false;\n    }\n  }], [{\n    key: \"createCheck\",\n    value: function createCheck(stack, obj) {\n      if (stack && stack.includes(obj)) {\n        throw new Error(\"\".concat(encodeErrPrefix, \" object contains circular references\"));\n      }\n      return new Ref(obj, stack);\n    }\n  }]);\n  return Ref;\n}();\nvar simpleTokens = {\n  null: new Token(Type.null, null),\n  undefined: new Token(Type.undefined, undefined),\n  true: new Token(Type.true, true),\n  false: new Token(Type.false, false),\n  emptyArray: new Token(Type.array, 0),\n  emptyMap: new Token(Type.map, 0)\n};\nvar typeEncoders = {\n  number: function number(obj, _typ, _options, _refStack) {\n    if (!Number.isInteger(obj) || !Number.isSafeInteger(obj)) {\n      return new Token(Type.float, obj);\n    } else if (obj >= 0) {\n      return new Token(Type.uint, obj);\n    } else {\n      return new Token(Type.negint, obj);\n    }\n  },\n  bigint: function bigint(obj, _typ, _options, _refStack) {\n    if (obj >= BigInt(0)) {\n      return new Token(Type.uint, obj);\n    } else {\n      return new Token(Type.negint, obj);\n    }\n  },\n  Uint8Array: function Uint8Array(obj, _typ, _options, _refStack) {\n    return new Token(Type.bytes, obj);\n  },\n  string: function string(obj, _typ, _options, _refStack) {\n    return new Token(Type.string, obj);\n  },\n  boolean: function boolean(obj, _typ, _options, _refStack) {\n    return obj ? simpleTokens.true : simpleTokens.false;\n  },\n  null: function _null(_obj, _typ, _options, _refStack) {\n    return simpleTokens.null;\n  },\n  undefined: function undefined(_obj, _typ, _options, _refStack) {\n    return simpleTokens.undefined;\n  },\n  ArrayBuffer: function ArrayBuffer(obj, _typ, _options, _refStack) {\n    return new Token(Type.bytes, new Uint8Array(obj));\n  },\n  DataView: function DataView(obj, _typ, _options, _refStack) {\n    return new Token(Type.bytes, new Uint8Array(obj.buffer, obj.byteOffset, obj.byteLength));\n  },\n  Array: function Array(obj, _typ, options, refStack) {\n    if (!obj.length) {\n      if (options.addBreakTokens === true) {\n        return [simpleTokens.emptyArray, new Token(Type.break)];\n      }\n      return simpleTokens.emptyArray;\n    }\n    refStack = Ref.createCheck(refStack, obj);\n    var entries = [];\n    var i = 0;\n    var _iterator = _createForOfIteratorHelper(obj),\n      _step;\n    try {\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        var e = _step.value;\n        entries[i++] = objectToTokens(e, options, refStack);\n      }\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n    if (options.addBreakTokens) {\n      return [new Token(Type.array, obj.length), entries, new Token(Type.break)];\n    }\n    return [new Token(Type.array, obj.length), entries];\n  },\n  Object: function (_Object) {\n    function Object(_x, _x2, _x3, _x4) {\n      return _Object.apply(this, arguments);\n    }\n    Object.toString = function () {\n      return _Object.toString();\n    };\n    return Object;\n  }(function (obj, typ, options, refStack) {\n    var isMap = typ !== 'Object';\n    var keys = isMap ? obj.keys() : Object.keys(obj);\n    var length = isMap ? obj.size : keys.length;\n    if (!length) {\n      if (options.addBreakTokens === true) {\n        return [simpleTokens.emptyMap, new Token(Type.break)];\n      }\n      return simpleTokens.emptyMap;\n    }\n    refStack = Ref.createCheck(refStack, obj);\n    var entries = [];\n    var i = 0;\n    var _iterator2 = _createForOfIteratorHelper(keys),\n      _step2;\n    try {\n      for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n        var key = _step2.value;\n        entries[i++] = [objectToTokens(key, options, refStack), objectToTokens(isMap ? obj.get(key) : obj[key], options, refStack)];\n      }\n    } catch (err) {\n      _iterator2.e(err);\n    } finally {\n      _iterator2.f();\n    }\n    sortMapEntries(entries, options);\n    if (options.addBreakTokens) {\n      return [new Token(Type.map, length), entries, new Token(Type.break)];\n    }\n    return [new Token(Type.map, length), entries];\n  })\n};\ntypeEncoders.Map = typeEncoders.Object;\ntypeEncoders.Buffer = typeEncoders.Uint8Array;\nvar _iterator3 = _createForOfIteratorHelper('Uint8Clamped Uint16 Uint32 Int8 Int16 Int32 BigUint64 BigInt64 Float32 Float64'.split(' ')),\n  _step3;\ntry {\n  for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n    var typ = _step3.value;\n    typeEncoders[\"\".concat(typ, \"Array\")] = typeEncoders.DataView;\n  }\n} catch (err) {\n  _iterator3.e(err);\n} finally {\n  _iterator3.f();\n}\nfunction objectToTokens(obj) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var refStack = arguments.length > 2 ? arguments[2] : undefined;\n  var typ = is(obj);\n  var customTypeEncoder = options && options.typeEncoders && options.typeEncoders[typ] || typeEncoders[typ];\n  if (typeof customTypeEncoder === 'function') {\n    var tokens = customTypeEncoder(obj, typ, options, refStack);\n    if (tokens != null) {\n      return tokens;\n    }\n  }\n  var typeEncoder = typeEncoders[typ];\n  if (!typeEncoder) {\n    throw new Error(\"\".concat(encodeErrPrefix, \" unsupported type: \").concat(typ));\n  }\n  return typeEncoder(obj, typ, options, refStack);\n}\nfunction sortMapEntries(entries, options) {\n  if (options.mapSorter) {\n    entries.sort(options.mapSorter);\n  }\n}\nfunction mapSorter(e1, e2) {\n  var keyToken1 = Array.isArray(e1[0]) ? e1[0][0] : e1[0];\n  var keyToken2 = Array.isArray(e2[0]) ? e2[0][0] : e2[0];\n  if (keyToken1.type !== keyToken2.type) {\n    return keyToken1.type.compare(keyToken2.type);\n  }\n  var major = keyToken1.type.major;\n  var tcmp = cborEncoders[major].compareTokens(keyToken1, keyToken2);\n  if (tcmp === 0) {\n    console.warn('WARNING: complex key types used, CBOR key sorting guarantees are gone');\n  }\n  return tcmp;\n}\nfunction tokensToEncoded(buf, tokens, encoders, options) {\n  if (Array.isArray(tokens)) {\n    var _iterator4 = _createForOfIteratorHelper(tokens),\n      _step4;\n    try {\n      for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n        var token = _step4.value;\n        tokensToEncoded(buf, token, encoders, options);\n      }\n    } catch (err) {\n      _iterator4.e(err);\n    } finally {\n      _iterator4.f();\n    }\n  } else {\n    encoders[tokens.type.major](buf, tokens, options);\n  }\n}\nfunction encodeCustom(data, encoders, options) {\n  var tokens = objectToTokens(data, options);\n  if (!Array.isArray(tokens) && options.quickEncodeToken) {\n    var quickBytes = options.quickEncodeToken(tokens);\n    if (quickBytes) {\n      return quickBytes;\n    }\n    var encoder = encoders[tokens.type.major];\n    if (encoder.encodedSize) {\n      var size = encoder.encodedSize(tokens, options);\n      var _buf = new Bl(size);\n      encoder(_buf, tokens, options);\n      if (_buf.chunks.length !== 1) {\n        throw new Error(\"Unexpected error: pre-calculated length for \".concat(tokens, \" was wrong\"));\n      }\n      return asU8A(_buf.chunks[0]);\n    }\n  }\n  buf.reset();\n  tokensToEncoded(buf, tokens, encoders, options);\n  return buf.toBytes(true);\n}\nfunction encode(data, options) {\n  options = Object.assign({}, defaultEncodeOptions, options);\n  return encodeCustom(data, cborEncoders, options);\n}\nexport { objectToTokens, encode, encodeCustom, Ref };","map":{"version":3,"names":["is","Token","Type","Bl","encodeErrPrefix","quickEncodeToken","asU8A","encodeUint","encodeNegint","encodeBytes","encodeString","encodeArray","encodeMap","encodeTag","encodeFloat","defaultEncodeOptions","float64","mapSorter","makeCborEncoders","encoders","uint","major","negint","bytes","string","array","map","tag","float","cborEncoders","buf","Ref","obj","parent","p","stack","includes","Error","simpleTokens","null","undefined","true","false","emptyArray","emptyMap","typeEncoders","number","_typ","_options","_refStack","Number","isInteger","isSafeInteger","bigint","BigInt","Uint8Array","boolean","_obj","ArrayBuffer","DataView","buffer","byteOffset","byteLength","Array","options","refStack","length","addBreakTokens","break","createCheck","entries","i","e","objectToTokens","Object","typ","isMap","keys","size","key","get","sortMapEntries","Map","Buffer","split","customTypeEncoder","tokens","typeEncoder","sort","e1","e2","keyToken1","isArray","keyToken2","type","compare","tcmp","compareTokens","console","warn","tokensToEncoded","token","encodeCustom","data","quickBytes","encoder","encodedSize","chunks","reset","toBytes","encode","assign"],"sources":["C:/Users/paete/Prototype/nftmusicProtoCopy/client/node_modules/cborg/esm/lib/encode.js"],"sourcesContent":["import { is } from './is.js';\nimport {\n  Token,\n  Type\n} from './token.js';\nimport { Bl } from './bl.js';\nimport { encodeErrPrefix } from './common.js';\nimport { quickEncodeToken } from './jump.js';\nimport { asU8A } from './byte-utils.js';\nimport { encodeUint } from './0uint.js';\nimport { encodeNegint } from './1negint.js';\nimport { encodeBytes } from './2bytes.js';\nimport { encodeString } from './3string.js';\nimport { encodeArray } from './4array.js';\nimport { encodeMap } from './5map.js';\nimport { encodeTag } from './6tag.js';\nimport { encodeFloat } from './7float.js';\nconst defaultEncodeOptions = {\n  float64: false,\n  mapSorter,\n  quickEncodeToken\n};\nexport function makeCborEncoders() {\n  const encoders = [];\n  encoders[Type.uint.major] = encodeUint;\n  encoders[Type.negint.major] = encodeNegint;\n  encoders[Type.bytes.major] = encodeBytes;\n  encoders[Type.string.major] = encodeString;\n  encoders[Type.array.major] = encodeArray;\n  encoders[Type.map.major] = encodeMap;\n  encoders[Type.tag.major] = encodeTag;\n  encoders[Type.float.major] = encodeFloat;\n  return encoders;\n}\nconst cborEncoders = makeCborEncoders();\nconst buf = new Bl();\nclass Ref {\n  constructor(obj, parent) {\n    this.obj = obj;\n    this.parent = parent;\n  }\n  includes(obj) {\n    let p = this;\n    do {\n      if (p.obj === obj) {\n        return true;\n      }\n    } while (p = p.parent);\n    return false;\n  }\n  static createCheck(stack, obj) {\n    if (stack && stack.includes(obj)) {\n      throw new Error(`${ encodeErrPrefix } object contains circular references`);\n    }\n    return new Ref(obj, stack);\n  }\n}\nconst simpleTokens = {\n  null: new Token(Type.null, null),\n  undefined: new Token(Type.undefined, undefined),\n  true: new Token(Type.true, true),\n  false: new Token(Type.false, false),\n  emptyArray: new Token(Type.array, 0),\n  emptyMap: new Token(Type.map, 0)\n};\nconst typeEncoders = {\n  number(obj, _typ, _options, _refStack) {\n    if (!Number.isInteger(obj) || !Number.isSafeInteger(obj)) {\n      return new Token(Type.float, obj);\n    } else if (obj >= 0) {\n      return new Token(Type.uint, obj);\n    } else {\n      return new Token(Type.negint, obj);\n    }\n  },\n  bigint(obj, _typ, _options, _refStack) {\n    if (obj >= BigInt(0)) {\n      return new Token(Type.uint, obj);\n    } else {\n      return new Token(Type.negint, obj);\n    }\n  },\n  Uint8Array(obj, _typ, _options, _refStack) {\n    return new Token(Type.bytes, obj);\n  },\n  string(obj, _typ, _options, _refStack) {\n    return new Token(Type.string, obj);\n  },\n  boolean(obj, _typ, _options, _refStack) {\n    return obj ? simpleTokens.true : simpleTokens.false;\n  },\n  null(_obj, _typ, _options, _refStack) {\n    return simpleTokens.null;\n  },\n  undefined(_obj, _typ, _options, _refStack) {\n    return simpleTokens.undefined;\n  },\n  ArrayBuffer(obj, _typ, _options, _refStack) {\n    return new Token(Type.bytes, new Uint8Array(obj));\n  },\n  DataView(obj, _typ, _options, _refStack) {\n    return new Token(Type.bytes, new Uint8Array(obj.buffer, obj.byteOffset, obj.byteLength));\n  },\n  Array(obj, _typ, options, refStack) {\n    if (!obj.length) {\n      if (options.addBreakTokens === true) {\n        return [\n          simpleTokens.emptyArray,\n          new Token(Type.break)\n        ];\n      }\n      return simpleTokens.emptyArray;\n    }\n    refStack = Ref.createCheck(refStack, obj);\n    const entries = [];\n    let i = 0;\n    for (const e of obj) {\n      entries[i++] = objectToTokens(e, options, refStack);\n    }\n    if (options.addBreakTokens) {\n      return [\n        new Token(Type.array, obj.length),\n        entries,\n        new Token(Type.break)\n      ];\n    }\n    return [\n      new Token(Type.array, obj.length),\n      entries\n    ];\n  },\n  Object(obj, typ, options, refStack) {\n    const isMap = typ !== 'Object';\n    const keys = isMap ? obj.keys() : Object.keys(obj);\n    const length = isMap ? obj.size : keys.length;\n    if (!length) {\n      if (options.addBreakTokens === true) {\n        return [\n          simpleTokens.emptyMap,\n          new Token(Type.break)\n        ];\n      }\n      return simpleTokens.emptyMap;\n    }\n    refStack = Ref.createCheck(refStack, obj);\n    const entries = [];\n    let i = 0;\n    for (const key of keys) {\n      entries[i++] = [\n        objectToTokens(key, options, refStack),\n        objectToTokens(isMap ? obj.get(key) : obj[key], options, refStack)\n      ];\n    }\n    sortMapEntries(entries, options);\n    if (options.addBreakTokens) {\n      return [\n        new Token(Type.map, length),\n        entries,\n        new Token(Type.break)\n      ];\n    }\n    return [\n      new Token(Type.map, length),\n      entries\n    ];\n  }\n};\ntypeEncoders.Map = typeEncoders.Object;\ntypeEncoders.Buffer = typeEncoders.Uint8Array;\nfor (const typ of 'Uint8Clamped Uint16 Uint32 Int8 Int16 Int32 BigUint64 BigInt64 Float32 Float64'.split(' ')) {\n  typeEncoders[`${ typ }Array`] = typeEncoders.DataView;\n}\nfunction objectToTokens(obj, options = {}, refStack) {\n  const typ = is(obj);\n  const customTypeEncoder = options && options.typeEncoders && options.typeEncoders[typ] || typeEncoders[typ];\n  if (typeof customTypeEncoder === 'function') {\n    const tokens = customTypeEncoder(obj, typ, options, refStack);\n    if (tokens != null) {\n      return tokens;\n    }\n  }\n  const typeEncoder = typeEncoders[typ];\n  if (!typeEncoder) {\n    throw new Error(`${ encodeErrPrefix } unsupported type: ${ typ }`);\n  }\n  return typeEncoder(obj, typ, options, refStack);\n}\nfunction sortMapEntries(entries, options) {\n  if (options.mapSorter) {\n    entries.sort(options.mapSorter);\n  }\n}\nfunction mapSorter(e1, e2) {\n  const keyToken1 = Array.isArray(e1[0]) ? e1[0][0] : e1[0];\n  const keyToken2 = Array.isArray(e2[0]) ? e2[0][0] : e2[0];\n  if (keyToken1.type !== keyToken2.type) {\n    return keyToken1.type.compare(keyToken2.type);\n  }\n  const major = keyToken1.type.major;\n  const tcmp = cborEncoders[major].compareTokens(keyToken1, keyToken2);\n  if (tcmp === 0) {\n    console.warn('WARNING: complex key types used, CBOR key sorting guarantees are gone');\n  }\n  return tcmp;\n}\nfunction tokensToEncoded(buf, tokens, encoders, options) {\n  if (Array.isArray(tokens)) {\n    for (const token of tokens) {\n      tokensToEncoded(buf, token, encoders, options);\n    }\n  } else {\n    encoders[tokens.type.major](buf, tokens, options);\n  }\n}\nfunction encodeCustom(data, encoders, options) {\n  const tokens = objectToTokens(data, options);\n  if (!Array.isArray(tokens) && options.quickEncodeToken) {\n    const quickBytes = options.quickEncodeToken(tokens);\n    if (quickBytes) {\n      return quickBytes;\n    }\n    const encoder = encoders[tokens.type.major];\n    if (encoder.encodedSize) {\n      const size = encoder.encodedSize(tokens, options);\n      const buf = new Bl(size);\n      encoder(buf, tokens, options);\n      if (buf.chunks.length !== 1) {\n        throw new Error(`Unexpected error: pre-calculated length for ${ tokens } was wrong`);\n      }\n      return asU8A(buf.chunks[0]);\n    }\n  }\n  buf.reset();\n  tokensToEncoded(buf, tokens, encoders, options);\n  return buf.toBytes(true);\n}\nfunction encode(data, options) {\n  options = Object.assign({}, defaultEncodeOptions, options);\n  return encodeCustom(data, cborEncoders, options);\n}\nexport {\n  objectToTokens,\n  encode,\n  encodeCustom,\n  Ref\n};"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}