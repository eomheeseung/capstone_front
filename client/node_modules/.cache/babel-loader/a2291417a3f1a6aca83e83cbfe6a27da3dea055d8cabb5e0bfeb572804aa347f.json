{"ast":null,"code":"\"use strict\";\n\n/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\nvar __generator = this && this.__generator || function (thisArg, body) {\n  var _ = {\n      label: 0,\n      sent: function () {\n        if (t[0] & 1) throw t[1];\n        return t[1];\n      },\n      trys: [],\n      ops: []\n    },\n    f,\n    y,\n    t,\n    g;\n  return g = {\n    next: verb(0),\n    \"throw\": verb(1),\n    \"return\": verb(2)\n  }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function () {\n    return this;\n  }), g;\n  function verb(n) {\n    return function (v) {\n      return step([n, v]);\n    };\n  }\n  function step(op) {\n    if (f) throw new TypeError(\"Generator is already executing.\");\n    while (g && (g = 0, op[0] && (_ = 0)), _) try {\n      if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n      if (y = 0, t) op = [op[0] & 2, t.value];\n      switch (op[0]) {\n        case 0:\n        case 1:\n          t = op;\n          break;\n        case 4:\n          _.label++;\n          return {\n            value: op[1],\n            done: false\n          };\n        case 5:\n          _.label++;\n          y = op[1];\n          op = [0];\n          continue;\n        case 7:\n          op = _.ops.pop();\n          _.trys.pop();\n          continue;\n        default:\n          if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {\n            _ = 0;\n            continue;\n          }\n          if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {\n            _.label = op[1];\n            break;\n          }\n          if (op[0] === 6 && _.label < t[1]) {\n            _.label = t[1];\n            t = op;\n            break;\n          }\n          if (t && _.label < t[2]) {\n            _.label = t[2];\n            _.ops.push(op);\n            break;\n          }\n          if (t[2]) _.ops.pop();\n          _.trys.pop();\n          continue;\n      }\n      op = body.call(thisArg, _);\n    } catch (e) {\n      op = [6, e];\n      y = 0;\n    } finally {\n      f = t = 0;\n    }\n    if (op[0] & 5) throw op[1];\n    return {\n      value: op[0] ? op[1] : void 0,\n      done: true\n    };\n  }\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getNumOfSavedModels = exports.loadSavedModel = exports.TFSavedModel = exports.getSignatureDefEntryFromMetaGraphInfo = exports.getMetaGraphsFromSavedModel = exports.readSavedModelProto = exports.getEnumKeyFromValue = void 0;\nvar tfjs_1 = require(\"@tensorflow/tfjs\");\nvar fs = require(\"fs\");\nvar util_1 = require(\"util\");\nvar nodejs_kernel_backend_1 = require(\"./nodejs_kernel_backend\");\nvar readFile = (0, util_1.promisify)(fs.readFile);\n// tslint:disable-next-line:no-require-imports\nvar messages = require('./proto/api_pb');\nvar SAVED_MODEL_FILE_NAME = '/saved_model.pb';\nvar SAVED_MODEL_INIT_OP_KEY = '__saved_model_init_op';\n// This map is used to keep track of loaded SavedModel metagraph mapping\n// information. The map key is TFSavedModel id in JavaScript, value is\n// an object of path to the SavedModel, metagraph tags, and loaded Session ID in\n// the c++ bindings. When user loads a SavedModel signature, it will go through\n// entries in this map to find if the corresponding SavedModel session has\n// already been loaded in C++ addon and will reuse it if existing.\nvar loadedSavedModelPathMap = new Map();\n// The ID of loaded TFSavedModel. This ID is used to keep track of loaded\n// TFSavedModel, so the loaded session in c++ bindings for the corresponding\n// TFSavedModel can be properly reused/disposed.\nvar nextTFSavedModelId = 0;\n/**\n * Get a key in an object by its value. This is used to get protobuf enum value\n * from index.\n *\n * @param object\n * @param value\n */\n// tslint:disable-next-line:no-any\nfunction getEnumKeyFromValue(object, value) {\n  return Object.keys(object).find(function (key) {\n    return object[key] === value;\n  });\n}\nexports.getEnumKeyFromValue = getEnumKeyFromValue;\n/**\n * Read SavedModel proto message from path.\n *\n * @param path Path to SavedModel folder.\n */\nfunction readSavedModelProto(path) {\n  return __awaiter(this, void 0, void 0, function () {\n    var modelFile, array;\n    return __generator(this, function (_a) {\n      switch (_a.label) {\n        case 0:\n          // Load the SavedModel pb file and deserialize it into message.\n          try {\n            fs.accessSync(path + SAVED_MODEL_FILE_NAME, fs.constants.R_OK);\n          } catch (error) {\n            throw new Error('There is no saved_model.pb file in the directory: ' + path);\n          }\n          return [4 /*yield*/, readFile(path + SAVED_MODEL_FILE_NAME)];\n        case 1:\n          modelFile = _a.sent();\n          array = new Uint8Array(modelFile);\n          return [2 /*return*/, messages.SavedModel.deserializeBinary(array)];\n      }\n    });\n  });\n}\nexports.readSavedModelProto = readSavedModelProto;\n/**\n * Inspect the MetaGraphs of the SavedModel from the provided path. This\n * function will return an array of `MetaGraphInfo` objects.\n *\n * @param path Path to SavedModel folder.\n *\n * @doc {heading: 'Models', subheading: 'SavedModel', namespace: 'node'}\n */\nfunction getMetaGraphsFromSavedModel(path) {\n  return __awaiter(this, void 0, void 0, function () {\n    var result, modelMessage, metaGraphList, i, metaGraph, tags, signatureDef, signatureDefMap, signatureDefKeys, key, signatureDefEntry, inputsMapMessage, inputsMapKeys, inputs, inputsMapKey, inputTensor, inputTensorInfo, dtype, outputsMapMessage, outputsMapKeys, outputs, outputsMapKey, outputTensor, outputTensorInfo, dtype;\n    return __generator(this, function (_a) {\n      switch (_a.label) {\n        case 0:\n          result = [];\n          return [4 /*yield*/, readSavedModelProto(path)];\n        case 1:\n          modelMessage = _a.sent();\n          metaGraphList = modelMessage.getMetaGraphsList();\n          for (i = 0; i < metaGraphList.length; i++) {\n            metaGraph = {};\n            tags = metaGraphList[i].getMetaInfoDef().getTagsList();\n            metaGraph.tags = tags;\n            signatureDef = {};\n            signatureDefMap = metaGraphList[i].getSignatureDefMap();\n            signatureDefKeys = signatureDefMap.keys();\n            // Go through all signatureDefs\n            while (true) {\n              key = signatureDefKeys.next();\n              if (key.done) {\n                break;\n              }\n              // Skip TensorFlow internal Signature '__saved_model_init_op'.\n              if (key.value === SAVED_MODEL_INIT_OP_KEY) {\n                continue;\n              }\n              signatureDefEntry = signatureDefMap.get(key.value);\n              inputsMapMessage = signatureDefEntry.getInputsMap();\n              inputsMapKeys = inputsMapMessage.keys();\n              inputs = {};\n              while (true) {\n                inputsMapKey = inputsMapKeys.next();\n                if (inputsMapKey.done) {\n                  break;\n                }\n                inputTensor = inputsMapMessage.get(inputsMapKey.value);\n                inputTensorInfo = {};\n                dtype = getEnumKeyFromValue(messages.DataType, inputTensor.getDtype());\n                inputTensorInfo.dtype = mapTFDtypeToJSDtype(dtype);\n                inputTensorInfo.tfDtype = dtype;\n                inputTensorInfo.name = inputTensor.getName();\n                inputTensorInfo.shape = inputTensor.getTensorShape().getDimList();\n                inputs[inputsMapKey.value] = inputTensorInfo;\n              }\n              outputsMapMessage = signatureDefEntry.getOutputsMap();\n              outputsMapKeys = outputsMapMessage.keys();\n              outputs = {};\n              while (true) {\n                outputsMapKey = outputsMapKeys.next();\n                if (outputsMapKey.done) {\n                  break;\n                }\n                outputTensor = outputsMapMessage.get(outputsMapKey.value);\n                outputTensorInfo = {};\n                dtype = getEnumKeyFromValue(messages.DataType, outputTensor.getDtype());\n                outputTensorInfo.dtype = mapTFDtypeToJSDtype(dtype);\n                outputTensorInfo.tfDtype = dtype;\n                outputTensorInfo.name = outputTensor.getName();\n                outputTensorInfo.shape = outputTensor.getTensorShape().getDimList();\n                outputs[outputsMapKey.value] = outputTensorInfo;\n              }\n              signatureDef[key.value] = {\n                inputs: inputs,\n                outputs: outputs\n              };\n            }\n            metaGraph.signatureDefs = signatureDef;\n            result.push(metaGraph);\n          }\n          return [2 /*return*/, result];\n      }\n    });\n  });\n}\nexports.getMetaGraphsFromSavedModel = getMetaGraphsFromSavedModel;\n/**\n * Get SignatureDefEntry from SavedModel metagraphs info. The SignatureDefEntry\n * will be used when executing a SavedModel signature.\n *\n * @param savedModelInfo The MetaGraphInfo array loaded through\n *     getMetaGraphsFromSavedModel().\n * @param tags The tags of the MetaGraph to get input/output node names from.\n * @param signature The signature to get input/output node names from.\n */\nfunction getSignatureDefEntryFromMetaGraphInfo(savedModelInfo, tags, signature) {\n  for (var i = 0; i < savedModelInfo.length; i++) {\n    var metaGraphInfo = savedModelInfo[i];\n    if (stringArraysHaveSameElements(tags, metaGraphInfo.tags)) {\n      if (metaGraphInfo.signatureDefs[signature] == null) {\n        throw new Error('The SavedModel does not have signature: ' + signature);\n      }\n      return metaGraphInfo.signatureDefs[signature];\n    }\n  }\n  throw new Error(\"The SavedModel does not have tags: \".concat(tags));\n}\nexports.getSignatureDefEntryFromMetaGraphInfo = getSignatureDefEntryFromMetaGraphInfo;\n/**\n * A `tf.TFSavedModel` is a signature loaded from a SavedModel\n * metagraph, and allows inference execution.\n *\n * @doc {heading: 'Models', subheading: 'SavedModel', namespace: 'node'}\n */\nvar TFSavedModel = /** @class */function () {\n  function TFSavedModel(sessionId, jsid, signature, backend) {\n    this.sessionId = sessionId;\n    this.jsid = jsid;\n    this.signature = signature;\n    this.backend = backend;\n    this.disposed = false;\n  }\n  Object.defineProperty(TFSavedModel.prototype, \"inputs\", {\n    /**\n     * Return the array of input tensor info.\n     *\n     * @doc {heading: 'Models', subheading: 'SavedModel'}\n     */\n    get: function () {\n      var entries = this.signature.inputs;\n      var results = Object.keys(entries).map(function (key) {\n        return entries[key];\n      });\n      results.forEach(function (info) {\n        info.name = info.name.replace(/:0$/, '');\n      });\n      return results;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  Object.defineProperty(TFSavedModel.prototype, \"outputs\", {\n    /**\n     * Return the array of output tensor info.\n     *\n     * @doc {heading: 'Models', subheading: 'SavedModel'}\n     */\n    get: function () {\n      var entries = this.signature.outputs;\n      var results = Object.keys(entries).map(function (key) {\n        return entries[key];\n      });\n      results.forEach(function (info) {\n        info.name = info.name.replace(/:0$/, '');\n      });\n      return results;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\n   * Delete the SavedModel from nodeBackend and delete corresponding session in\n   * the C++ backend if the session is only used by this TFSavedModel.\n   *\n   * @doc {heading: 'Models', subheading: 'SavedModel'}\n   */\n  TFSavedModel.prototype.dispose = function () {\n    if (!this.disposed) {\n      this.disposed = true;\n      loadedSavedModelPathMap.delete(this.jsid);\n      for (var _i = 0, _a = Array.from(loadedSavedModelPathMap.keys()); _i < _a.length; _i++) {\n        var id = _a[_i];\n        var value = loadedSavedModelPathMap.get(id);\n        if (value.sessionId === this.sessionId) {\n          return;\n        }\n      }\n      this.backend.deleteSavedModel(this.sessionId);\n    } else {\n      throw new Error('This SavedModel has already been deleted.');\n    }\n  };\n  Object.defineProperty(TFSavedModel.prototype, \"outputNodeNames\", {\n    get: function () {\n      var _this = this;\n      if (this.outputNodeNames_ != null) {\n        return this.outputNodeNames_;\n      }\n      this.outputNodeNames_ = Object.keys(this.signature.outputs).reduce(function (names, key) {\n        names[key] = _this.signature.outputs[key].name;\n        return names;\n      }, {});\n      return this.outputNodeNames_;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\n   * Execute the inference for the input tensors.\n   *\n   * @param input The input tensors, when there is single input for the model,\n   * inputs param should be a Tensor. For models with multiple inputs, inputs\n   * params should be in either Tensor[] if the input order is fixed, or\n   * otherwise NamedTensorMap format. The keys in the NamedTensorMap are the\n   * name of input tensors in SavedModel signatureDef. It can be found through\n   * `tf.node.getMetaGraphsFromSavedModel()`.\n   *\n   * For batch inference execution, the tensors for each input need to be\n   * concatenated together. For example with mobilenet, the required input shape\n   * is [1, 244, 244, 3], which represents the [batch, height, width, channel].\n   * If we are provide a batched data of 100 images, the input tensor should be\n   * in the shape of [100, 244, 244, 3].\n   *\n   * @param config Prediction configuration for specifying the batch size.\n   *\n   * @returns Inference result tensors. The output would be single Tensor if\n   * model has single output node, otherwise Tensor[] or NamedTensorMap[] will\n   * be returned for model with multiple outputs.\n   *\n   * @doc {heading: 'Models', subheading: 'SavedModel'}\n   */\n  TFSavedModel.prototype.predict = function (inputs, config) {\n    var _this = this;\n    if (this.disposed) {\n      throw new Error('The TFSavedModel has already been deleted!');\n    } else {\n      var inputTensors = [];\n      if (inputs instanceof tfjs_1.Tensor) {\n        inputTensors.push(inputs);\n        var result = this.backend.runSavedModel(this.sessionId, inputTensors, Object.values(this.signature.inputs), Object.values(this.outputNodeNames));\n        return result.length > 1 ? result : result[0];\n      } else if (Array.isArray(inputs)) {\n        inputTensors = inputs;\n        return this.backend.runSavedModel(this.sessionId, inputTensors, Object.values(this.signature.inputs), Object.values(this.outputNodeNames));\n      } else {\n        var inputTensorNames = Object.keys(this.signature.inputs);\n        var providedInputNames = Object.keys(inputs);\n        if (!stringArraysHaveSameElements(inputTensorNames, providedInputNames)) {\n          throw new Error(\"The model signatureDef input names are \".concat(inputTensorNames.join(), \", however the provided input names are \").concat(providedInputNames.join(), \".\"));\n        }\n        var inputNodeNamesArray = [];\n        for (var i = 0; i < inputTensorNames.length; i++) {\n          inputTensors.push(inputs[inputTensorNames[i]]);\n          inputNodeNamesArray.push(this.signature.inputs[inputTensorNames[i]]);\n        }\n        var outputTensorNames = Object.keys(this.outputNodeNames);\n        var outputNodeNamesArray = [];\n        for (var i = 0; i < outputTensorNames.length; i++) {\n          outputNodeNamesArray.push(this.outputNodeNames[outputTensorNames[i]]);\n        }\n        var outputTensors_1 = this.backend.runSavedModel(this.sessionId, inputTensors, inputNodeNamesArray, outputNodeNamesArray);\n        tfjs_1.util.assert(outputTensors_1.length === outputNodeNamesArray.length, function () {\n          return 'Output tensors do not match output node names, ' + \"receive \".concat(outputTensors_1.length, \") output tensors but \") + \"there are \".concat(_this.outputNodeNames.length, \" output nodes.\");\n        });\n        var outputMap = {};\n        for (var i = 0; i < outputTensorNames.length; i++) {\n          outputMap[outputTensorNames[i]] = outputTensors_1[i];\n        }\n        return outputMap;\n      }\n    }\n  };\n  /**\n   * Execute the inference for the input tensors and return activation\n   * values for specified output node names without batching.\n   *\n   * @param input The input tensors, when there is single input for the model,\n   * inputs param should be a Tensor. For models with multiple inputs, inputs\n   * params should be in either Tensor[] if the input order is fixed, or\n   * otherwise NamedTensorMap format.\n   *\n   * @param outputs string|string[]. List of output node names to retrieve\n   * activation from.\n   *\n   * @returns Activation values for the output nodes result tensors. The return\n   * type matches specified parameter outputs type. The output would be single\n   * Tensor if single output is specified, otherwise Tensor[] for multiple\n   * outputs.\n   *\n   * @doc {heading: 'Models', subheading: 'SavedModel'}\n   */\n  TFSavedModel.prototype.execute = function (inputs, outputs) {\n    throw new Error('execute() of TFSavedModel is not supported yet.');\n  };\n  return TFSavedModel;\n}();\nexports.TFSavedModel = TFSavedModel;\n/**\n * Load a TensorFlow SavedModel from disk. TensorFlow SavedModel is different\n * from TensorFlow.js model format. A SavedModel is a directory containing\n * serialized signatures and the states needed to run them. The directory has a\n * saved_model.pb (or saved_model.pbtxt) file storing the actual TensorFlow\n * program, or model, and a set of named signatures, each identifying a\n * function. The directory also has a variables directory contains a standard\n * training checkpoint. The directory may also has a assets directory contains\n * files used by the TensorFlow graph, for example text files used to initialize\n * vocabulary tables. These are supported datatypes: float32, int32, complex64,\n * string.For more information, see this guide:\n * https://www.tensorflow.org/guide/saved_model.\n *\n * @param path The path to the SavedModel.\n * @param tags The tags of the MetaGraph to load. The available tags of a\n *     SavedModel can be retrieved through tf.node.getMetaGraphsFromSavedModel()\n *     API. Defaults to ['serve'].\n * @param signature The name of the SignatureDef to load. The available\n *     SignatureDefs of a SavedModel can be retrieved through\n *     tf.node.getMetaGraphsFromSavedModel() API. Defaults to 'serving_default'.\n *\n * @doc {heading: 'Models', subheading: 'SavedModel', namespace: 'node'}\n */\nfunction loadSavedModel(path, tags, signature) {\n  if (tags === void 0) {\n    tags = ['serve'];\n  }\n  if (signature === void 0) {\n    signature = 'serving_default';\n  }\n  return __awaiter(this, void 0, void 0, function () {\n    var backend, savedModelInfo, signatureDefEntry, sessionId, _i, _a, id_1, modelInfo, tagsString, id, savedModel;\n    return __generator(this, function (_b) {\n      switch (_b.label) {\n        case 0:\n          (0, nodejs_kernel_backend_1.ensureTensorflowBackend)();\n          backend = (0, nodejs_kernel_backend_1.nodeBackend)();\n          return [4 /*yield*/, getMetaGraphsFromSavedModel(path)];\n        case 1:\n          savedModelInfo = _b.sent();\n          signatureDefEntry = getSignatureDefEntryFromMetaGraphInfo(savedModelInfo, tags, signature);\n          for (_i = 0, _a = Array.from(loadedSavedModelPathMap.keys()); _i < _a.length; _i++) {\n            id_1 = _a[_i];\n            modelInfo = loadedSavedModelPathMap.get(id_1);\n            if (modelInfo.path === path && stringArraysHaveSameElements(modelInfo.tags, tags)) {\n              sessionId = modelInfo.sessionId;\n            }\n          }\n          if (sessionId == null) {\n            tagsString = tags.join(',');\n            sessionId = backend.loadSavedModelMetaGraph(path, tagsString);\n          }\n          id = nextTFSavedModelId++;\n          savedModel = new TFSavedModel(sessionId, id, signatureDefEntry, backend);\n          loadedSavedModelPathMap.set(id, {\n            path: path,\n            tags: tags,\n            sessionId: sessionId\n          });\n          return [2 /*return*/, savedModel];\n      }\n    });\n  });\n}\nexports.loadSavedModel = loadSavedModel;\n/**\n * Compare if two unsorted arrays of string have the same elements.\n * @param arrayA\n * @param arrayB\n */\nfunction stringArraysHaveSameElements(arrayA, arrayB) {\n  if (arrayA.length === arrayB.length && arrayA.sort().join() === arrayB.sort().join()) {\n    return true;\n  }\n  return false;\n}\nfunction mapTFDtypeToJSDtype(tfDtype) {\n  switch (tfDtype) {\n    case 'DT_FLOAT':\n      return 'float32';\n    case 'DT_INT64':\n    case 'DT_INT32':\n    case 'DT_UINT8':\n      return 'int32';\n    case 'DT_BOOL':\n      return 'bool';\n    case 'DT_COMPLEX64':\n      return 'complex64';\n    case 'DT_STRING':\n      return 'string';\n    default:\n      throw new Error('Unsupported tensor DataType: ' + tfDtype + ', try to modify the model in python to convert the datatype');\n  }\n}\nfunction getNumOfSavedModels() {\n  (0, nodejs_kernel_backend_1.ensureTensorflowBackend)();\n  var backend = (0, nodejs_kernel_backend_1.nodeBackend)();\n  return backend.getNumOfSavedModels();\n}\nexports.getNumOfSavedModels = getNumOfSavedModels;","map":{"version":3,"names":["__awaiter","thisArg","_arguments","P","generator","adopt","value","resolve","Promise","reject","fulfilled","step","next","e","rejected","result","done","then","apply","__generator","body","_","label","sent","t","trys","ops","f","y","g","verb","Symbol","iterator","n","v","op","TypeError","call","pop","length","push","Object","defineProperty","exports","getNumOfSavedModels","loadSavedModel","TFSavedModel","getSignatureDefEntryFromMetaGraphInfo","getMetaGraphsFromSavedModel","readSavedModelProto","getEnumKeyFromValue","tfjs_1","require","fs","util_1","nodejs_kernel_backend_1","readFile","promisify","messages","SAVED_MODEL_FILE_NAME","SAVED_MODEL_INIT_OP_KEY","loadedSavedModelPathMap","Map","nextTFSavedModelId","object","keys","find","key","path","modelFile","array","_a","accessSync","constants","R_OK","error","Error","Uint8Array","SavedModel","deserializeBinary","modelMessage","metaGraphList","i","metaGraph","tags","signatureDef","signatureDefMap","signatureDefKeys","signatureDefEntry","inputsMapMessage","inputsMapKeys","inputs","inputsMapKey","inputTensor","inputTensorInfo","dtype","outputsMapMessage","outputsMapKeys","outputs","outputsMapKey","outputTensor","outputTensorInfo","getMetaGraphsList","getMetaInfoDef","getTagsList","getSignatureDefMap","get","getInputsMap","DataType","getDtype","mapTFDtypeToJSDtype","tfDtype","name","getName","shape","getTensorShape","getDimList","getOutputsMap","signatureDefs","savedModelInfo","signature","metaGraphInfo","stringArraysHaveSameElements","concat","sessionId","jsid","backend","disposed","prototype","entries","results","map","forEach","info","replace","enumerable","configurable","dispose","delete","_i","Array","from","id","deleteSavedModel","_this","outputNodeNames_","reduce","names","predict","config","inputTensors","Tensor","runSavedModel","values","outputNodeNames","isArray","inputTensorNames","providedInputNames","join","inputNodeNamesArray","outputTensorNames","outputNodeNamesArray","outputTensors_1","util","assert","outputMap","execute","id_1","modelInfo","tagsString","savedModel","_b","ensureTensorflowBackend","nodeBackend","loadSavedModelMetaGraph","set","arrayA","arrayB","sort"],"sources":["C:/Users/paete/CapstonPro/nftmusicProtoCopy/client/node_modules/@tensorflow/tfjs-node/dist/saved_model.js"],"sourcesContent":["\"use strict\";\n/**\n * @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (this && this.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (g && (g = 0, op[0] && (_ = 0)), _) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.getNumOfSavedModels = exports.loadSavedModel = exports.TFSavedModel = exports.getSignatureDefEntryFromMetaGraphInfo = exports.getMetaGraphsFromSavedModel = exports.readSavedModelProto = exports.getEnumKeyFromValue = void 0;\nvar tfjs_1 = require(\"@tensorflow/tfjs\");\nvar fs = require(\"fs\");\nvar util_1 = require(\"util\");\nvar nodejs_kernel_backend_1 = require(\"./nodejs_kernel_backend\");\nvar readFile = (0, util_1.promisify)(fs.readFile);\n// tslint:disable-next-line:no-require-imports\nvar messages = require('./proto/api_pb');\nvar SAVED_MODEL_FILE_NAME = '/saved_model.pb';\nvar SAVED_MODEL_INIT_OP_KEY = '__saved_model_init_op';\n// This map is used to keep track of loaded SavedModel metagraph mapping\n// information. The map key is TFSavedModel id in JavaScript, value is\n// an object of path to the SavedModel, metagraph tags, and loaded Session ID in\n// the c++ bindings. When user loads a SavedModel signature, it will go through\n// entries in this map to find if the corresponding SavedModel session has\n// already been loaded in C++ addon and will reuse it if existing.\nvar loadedSavedModelPathMap = new Map();\n// The ID of loaded TFSavedModel. This ID is used to keep track of loaded\n// TFSavedModel, so the loaded session in c++ bindings for the corresponding\n// TFSavedModel can be properly reused/disposed.\nvar nextTFSavedModelId = 0;\n/**\n * Get a key in an object by its value. This is used to get protobuf enum value\n * from index.\n *\n * @param object\n * @param value\n */\n// tslint:disable-next-line:no-any\nfunction getEnumKeyFromValue(object, value) {\n    return Object.keys(object).find(function (key) { return object[key] === value; });\n}\nexports.getEnumKeyFromValue = getEnumKeyFromValue;\n/**\n * Read SavedModel proto message from path.\n *\n * @param path Path to SavedModel folder.\n */\nfunction readSavedModelProto(path) {\n    return __awaiter(this, void 0, void 0, function () {\n        var modelFile, array;\n        return __generator(this, function (_a) {\n            switch (_a.label) {\n                case 0:\n                    // Load the SavedModel pb file and deserialize it into message.\n                    try {\n                        fs.accessSync(path + SAVED_MODEL_FILE_NAME, fs.constants.R_OK);\n                    }\n                    catch (error) {\n                        throw new Error('There is no saved_model.pb file in the directory: ' + path);\n                    }\n                    return [4 /*yield*/, readFile(path + SAVED_MODEL_FILE_NAME)];\n                case 1:\n                    modelFile = _a.sent();\n                    array = new Uint8Array(modelFile);\n                    return [2 /*return*/, messages.SavedModel.deserializeBinary(array)];\n            }\n        });\n    });\n}\nexports.readSavedModelProto = readSavedModelProto;\n/**\n * Inspect the MetaGraphs of the SavedModel from the provided path. This\n * function will return an array of `MetaGraphInfo` objects.\n *\n * @param path Path to SavedModel folder.\n *\n * @doc {heading: 'Models', subheading: 'SavedModel', namespace: 'node'}\n */\nfunction getMetaGraphsFromSavedModel(path) {\n    return __awaiter(this, void 0, void 0, function () {\n        var result, modelMessage, metaGraphList, i, metaGraph, tags, signatureDef, signatureDefMap, signatureDefKeys, key, signatureDefEntry, inputsMapMessage, inputsMapKeys, inputs, inputsMapKey, inputTensor, inputTensorInfo, dtype, outputsMapMessage, outputsMapKeys, outputs, outputsMapKey, outputTensor, outputTensorInfo, dtype;\n        return __generator(this, function (_a) {\n            switch (_a.label) {\n                case 0:\n                    result = [];\n                    return [4 /*yield*/, readSavedModelProto(path)];\n                case 1:\n                    modelMessage = _a.sent();\n                    metaGraphList = modelMessage.getMetaGraphsList();\n                    for (i = 0; i < metaGraphList.length; i++) {\n                        metaGraph = {};\n                        tags = metaGraphList[i].getMetaInfoDef().getTagsList();\n                        metaGraph.tags = tags;\n                        signatureDef = {};\n                        signatureDefMap = metaGraphList[i].getSignatureDefMap();\n                        signatureDefKeys = signatureDefMap.keys();\n                        // Go through all signatureDefs\n                        while (true) {\n                            key = signatureDefKeys.next();\n                            if (key.done) {\n                                break;\n                            }\n                            // Skip TensorFlow internal Signature '__saved_model_init_op'.\n                            if (key.value === SAVED_MODEL_INIT_OP_KEY) {\n                                continue;\n                            }\n                            signatureDefEntry = signatureDefMap.get(key.value);\n                            inputsMapMessage = signatureDefEntry.getInputsMap();\n                            inputsMapKeys = inputsMapMessage.keys();\n                            inputs = {};\n                            while (true) {\n                                inputsMapKey = inputsMapKeys.next();\n                                if (inputsMapKey.done) {\n                                    break;\n                                }\n                                inputTensor = inputsMapMessage.get(inputsMapKey.value);\n                                inputTensorInfo = {};\n                                dtype = getEnumKeyFromValue(messages.DataType, inputTensor.getDtype());\n                                inputTensorInfo.dtype = mapTFDtypeToJSDtype(dtype);\n                                inputTensorInfo.tfDtype = dtype;\n                                inputTensorInfo.name = inputTensor.getName();\n                                inputTensorInfo.shape = inputTensor.getTensorShape().getDimList();\n                                inputs[inputsMapKey.value] = inputTensorInfo;\n                            }\n                            outputsMapMessage = signatureDefEntry.getOutputsMap();\n                            outputsMapKeys = outputsMapMessage.keys();\n                            outputs = {};\n                            while (true) {\n                                outputsMapKey = outputsMapKeys.next();\n                                if (outputsMapKey.done) {\n                                    break;\n                                }\n                                outputTensor = outputsMapMessage.get(outputsMapKey.value);\n                                outputTensorInfo = {};\n                                dtype = getEnumKeyFromValue(messages.DataType, outputTensor.getDtype());\n                                outputTensorInfo.dtype = mapTFDtypeToJSDtype(dtype);\n                                outputTensorInfo.tfDtype = dtype;\n                                outputTensorInfo.name = outputTensor.getName();\n                                outputTensorInfo.shape = outputTensor.getTensorShape().getDimList();\n                                outputs[outputsMapKey.value] = outputTensorInfo;\n                            }\n                            signatureDef[key.value] = { inputs: inputs, outputs: outputs };\n                        }\n                        metaGraph.signatureDefs = signatureDef;\n                        result.push(metaGraph);\n                    }\n                    return [2 /*return*/, result];\n            }\n        });\n    });\n}\nexports.getMetaGraphsFromSavedModel = getMetaGraphsFromSavedModel;\n/**\n * Get SignatureDefEntry from SavedModel metagraphs info. The SignatureDefEntry\n * will be used when executing a SavedModel signature.\n *\n * @param savedModelInfo The MetaGraphInfo array loaded through\n *     getMetaGraphsFromSavedModel().\n * @param tags The tags of the MetaGraph to get input/output node names from.\n * @param signature The signature to get input/output node names from.\n */\nfunction getSignatureDefEntryFromMetaGraphInfo(savedModelInfo, tags, signature) {\n    for (var i = 0; i < savedModelInfo.length; i++) {\n        var metaGraphInfo = savedModelInfo[i];\n        if (stringArraysHaveSameElements(tags, metaGraphInfo.tags)) {\n            if (metaGraphInfo.signatureDefs[signature] == null) {\n                throw new Error('The SavedModel does not have signature: ' + signature);\n            }\n            return metaGraphInfo.signatureDefs[signature];\n        }\n    }\n    throw new Error(\"The SavedModel does not have tags: \".concat(tags));\n}\nexports.getSignatureDefEntryFromMetaGraphInfo = getSignatureDefEntryFromMetaGraphInfo;\n/**\n * A `tf.TFSavedModel` is a signature loaded from a SavedModel\n * metagraph, and allows inference execution.\n *\n * @doc {heading: 'Models', subheading: 'SavedModel', namespace: 'node'}\n */\nvar TFSavedModel = /** @class */ (function () {\n    function TFSavedModel(sessionId, jsid, signature, backend) {\n        this.sessionId = sessionId;\n        this.jsid = jsid;\n        this.signature = signature;\n        this.backend = backend;\n        this.disposed = false;\n    }\n    Object.defineProperty(TFSavedModel.prototype, \"inputs\", {\n        /**\n         * Return the array of input tensor info.\n         *\n         * @doc {heading: 'Models', subheading: 'SavedModel'}\n         */\n        get: function () {\n            var entries = this.signature.inputs;\n            var results = Object.keys(entries).map(function (key) { return entries[key]; });\n            results.forEach(function (info) {\n                info.name = info.name.replace(/:0$/, '');\n            });\n            return results;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Object.defineProperty(TFSavedModel.prototype, \"outputs\", {\n        /**\n         * Return the array of output tensor info.\n         *\n         * @doc {heading: 'Models', subheading: 'SavedModel'}\n         */\n        get: function () {\n            var entries = this.signature.outputs;\n            var results = Object.keys(entries).map(function (key) { return entries[key]; });\n            results.forEach(function (info) {\n                info.name = info.name.replace(/:0$/, '');\n            });\n            return results;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    /**\n     * Delete the SavedModel from nodeBackend and delete corresponding session in\n     * the C++ backend if the session is only used by this TFSavedModel.\n     *\n     * @doc {heading: 'Models', subheading: 'SavedModel'}\n     */\n    TFSavedModel.prototype.dispose = function () {\n        if (!this.disposed) {\n            this.disposed = true;\n            loadedSavedModelPathMap.delete(this.jsid);\n            for (var _i = 0, _a = Array.from(loadedSavedModelPathMap.keys()); _i < _a.length; _i++) {\n                var id = _a[_i];\n                var value = loadedSavedModelPathMap.get(id);\n                if (value.sessionId === this.sessionId) {\n                    return;\n                }\n            }\n            this.backend.deleteSavedModel(this.sessionId);\n        }\n        else {\n            throw new Error('This SavedModel has already been deleted.');\n        }\n    };\n    Object.defineProperty(TFSavedModel.prototype, \"outputNodeNames\", {\n        get: function () {\n            var _this = this;\n            if (this.outputNodeNames_ != null) {\n                return this.outputNodeNames_;\n            }\n            this.outputNodeNames_ =\n                Object.keys(this.signature.outputs)\n                    .reduce(function (names, key) {\n                    names[key] = _this.signature.outputs[key].name;\n                    return names;\n                }, {});\n            return this.outputNodeNames_;\n        },\n        enumerable: false,\n        configurable: true\n    });\n    /**\n     * Execute the inference for the input tensors.\n     *\n     * @param input The input tensors, when there is single input for the model,\n     * inputs param should be a Tensor. For models with multiple inputs, inputs\n     * params should be in either Tensor[] if the input order is fixed, or\n     * otherwise NamedTensorMap format. The keys in the NamedTensorMap are the\n     * name of input tensors in SavedModel signatureDef. It can be found through\n     * `tf.node.getMetaGraphsFromSavedModel()`.\n     *\n     * For batch inference execution, the tensors for each input need to be\n     * concatenated together. For example with mobilenet, the required input shape\n     * is [1, 244, 244, 3], which represents the [batch, height, width, channel].\n     * If we are provide a batched data of 100 images, the input tensor should be\n     * in the shape of [100, 244, 244, 3].\n     *\n     * @param config Prediction configuration for specifying the batch size.\n     *\n     * @returns Inference result tensors. The output would be single Tensor if\n     * model has single output node, otherwise Tensor[] or NamedTensorMap[] will\n     * be returned for model with multiple outputs.\n     *\n     * @doc {heading: 'Models', subheading: 'SavedModel'}\n     */\n    TFSavedModel.prototype.predict = function (inputs, config) {\n        var _this = this;\n        if (this.disposed) {\n            throw new Error('The TFSavedModel has already been deleted!');\n        }\n        else {\n            var inputTensors = [];\n            if (inputs instanceof tfjs_1.Tensor) {\n                inputTensors.push(inputs);\n                var result = this.backend.runSavedModel(this.sessionId, inputTensors, Object.values(this.signature.inputs), Object.values(this.outputNodeNames));\n                return result.length > 1 ? result : result[0];\n            }\n            else if (Array.isArray(inputs)) {\n                inputTensors = inputs;\n                return this.backend.runSavedModel(this.sessionId, inputTensors, Object.values(this.signature.inputs), Object.values(this.outputNodeNames));\n            }\n            else {\n                var inputTensorNames = Object.keys(this.signature.inputs);\n                var providedInputNames = Object.keys(inputs);\n                if (!stringArraysHaveSameElements(inputTensorNames, providedInputNames)) {\n                    throw new Error(\"The model signatureDef input names are \".concat(inputTensorNames.join(), \", however the provided input names are \").concat(providedInputNames.join(), \".\"));\n                }\n                var inputNodeNamesArray = [];\n                for (var i = 0; i < inputTensorNames.length; i++) {\n                    inputTensors.push(inputs[inputTensorNames[i]]);\n                    inputNodeNamesArray.push(this.signature.inputs[inputTensorNames[i]]);\n                }\n                var outputTensorNames = Object.keys(this.outputNodeNames);\n                var outputNodeNamesArray = [];\n                for (var i = 0; i < outputTensorNames.length; i++) {\n                    outputNodeNamesArray.push(this.outputNodeNames[outputTensorNames[i]]);\n                }\n                var outputTensors_1 = this.backend.runSavedModel(this.sessionId, inputTensors, inputNodeNamesArray, outputNodeNamesArray);\n                tfjs_1.util.assert(outputTensors_1.length === outputNodeNamesArray.length, function () { return 'Output tensors do not match output node names, ' +\n                    \"receive \".concat(outputTensors_1.length, \") output tensors but \") +\n                    \"there are \".concat(_this.outputNodeNames.length, \" output nodes.\"); });\n                var outputMap = {};\n                for (var i = 0; i < outputTensorNames.length; i++) {\n                    outputMap[outputTensorNames[i]] = outputTensors_1[i];\n                }\n                return outputMap;\n            }\n        }\n    };\n    /**\n     * Execute the inference for the input tensors and return activation\n     * values for specified output node names without batching.\n     *\n     * @param input The input tensors, when there is single input for the model,\n     * inputs param should be a Tensor. For models with multiple inputs, inputs\n     * params should be in either Tensor[] if the input order is fixed, or\n     * otherwise NamedTensorMap format.\n     *\n     * @param outputs string|string[]. List of output node names to retrieve\n     * activation from.\n     *\n     * @returns Activation values for the output nodes result tensors. The return\n     * type matches specified parameter outputs type. The output would be single\n     * Tensor if single output is specified, otherwise Tensor[] for multiple\n     * outputs.\n     *\n     * @doc {heading: 'Models', subheading: 'SavedModel'}\n     */\n    TFSavedModel.prototype.execute = function (inputs, outputs) {\n        throw new Error('execute() of TFSavedModel is not supported yet.');\n    };\n    return TFSavedModel;\n}());\nexports.TFSavedModel = TFSavedModel;\n/**\n * Load a TensorFlow SavedModel from disk. TensorFlow SavedModel is different\n * from TensorFlow.js model format. A SavedModel is a directory containing\n * serialized signatures and the states needed to run them. The directory has a\n * saved_model.pb (or saved_model.pbtxt) file storing the actual TensorFlow\n * program, or model, and a set of named signatures, each identifying a\n * function. The directory also has a variables directory contains a standard\n * training checkpoint. The directory may also has a assets directory contains\n * files used by the TensorFlow graph, for example text files used to initialize\n * vocabulary tables. These are supported datatypes: float32, int32, complex64,\n * string.For more information, see this guide:\n * https://www.tensorflow.org/guide/saved_model.\n *\n * @param path The path to the SavedModel.\n * @param tags The tags of the MetaGraph to load. The available tags of a\n *     SavedModel can be retrieved through tf.node.getMetaGraphsFromSavedModel()\n *     API. Defaults to ['serve'].\n * @param signature The name of the SignatureDef to load. The available\n *     SignatureDefs of a SavedModel can be retrieved through\n *     tf.node.getMetaGraphsFromSavedModel() API. Defaults to 'serving_default'.\n *\n * @doc {heading: 'Models', subheading: 'SavedModel', namespace: 'node'}\n */\nfunction loadSavedModel(path, tags, signature) {\n    if (tags === void 0) { tags = ['serve']; }\n    if (signature === void 0) { signature = 'serving_default'; }\n    return __awaiter(this, void 0, void 0, function () {\n        var backend, savedModelInfo, signatureDefEntry, sessionId, _i, _a, id_1, modelInfo, tagsString, id, savedModel;\n        return __generator(this, function (_b) {\n            switch (_b.label) {\n                case 0:\n                    (0, nodejs_kernel_backend_1.ensureTensorflowBackend)();\n                    backend = (0, nodejs_kernel_backend_1.nodeBackend)();\n                    return [4 /*yield*/, getMetaGraphsFromSavedModel(path)];\n                case 1:\n                    savedModelInfo = _b.sent();\n                    signatureDefEntry = getSignatureDefEntryFromMetaGraphInfo(savedModelInfo, tags, signature);\n                    for (_i = 0, _a = Array.from(loadedSavedModelPathMap.keys()); _i < _a.length; _i++) {\n                        id_1 = _a[_i];\n                        modelInfo = loadedSavedModelPathMap.get(id_1);\n                        if (modelInfo.path === path &&\n                            stringArraysHaveSameElements(modelInfo.tags, tags)) {\n                            sessionId = modelInfo.sessionId;\n                        }\n                    }\n                    if (sessionId == null) {\n                        tagsString = tags.join(',');\n                        sessionId = backend.loadSavedModelMetaGraph(path, tagsString);\n                    }\n                    id = nextTFSavedModelId++;\n                    savedModel = new TFSavedModel(sessionId, id, signatureDefEntry, backend);\n                    loadedSavedModelPathMap.set(id, { path: path, tags: tags, sessionId: sessionId });\n                    return [2 /*return*/, savedModel];\n            }\n        });\n    });\n}\nexports.loadSavedModel = loadSavedModel;\n/**\n * Compare if two unsorted arrays of string have the same elements.\n * @param arrayA\n * @param arrayB\n */\nfunction stringArraysHaveSameElements(arrayA, arrayB) {\n    if (arrayA.length === arrayB.length &&\n        arrayA.sort().join() === arrayB.sort().join()) {\n        return true;\n    }\n    return false;\n}\nfunction mapTFDtypeToJSDtype(tfDtype) {\n    switch (tfDtype) {\n        case 'DT_FLOAT':\n            return 'float32';\n        case 'DT_INT64':\n        case 'DT_INT32':\n        case 'DT_UINT8':\n            return 'int32';\n        case 'DT_BOOL':\n            return 'bool';\n        case 'DT_COMPLEX64':\n            return 'complex64';\n        case 'DT_STRING':\n            return 'string';\n        default:\n            throw new Error('Unsupported tensor DataType: ' + tfDtype +\n                ', try to modify the model in python to convert the datatype');\n    }\n}\nfunction getNumOfSavedModels() {\n    (0, nodejs_kernel_backend_1.ensureTensorflowBackend)();\n    var backend = (0, nodejs_kernel_backend_1.nodeBackend)();\n    return backend.getNumOfSavedModels();\n}\nexports.getNumOfSavedModels = getNumOfSavedModels;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}