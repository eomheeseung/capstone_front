{"ast":null,"code":"'use strict';\n\nvar _regeneratorRuntime = require(\"C:/Users/paete/Prototype/nftmusicProtoCopy/client/node_modules/@babel/runtime/helpers/regeneratorRuntime.js\").default;\nvar _objectSpread = require(\"C:/Users/paete/Prototype/nftmusicProtoCopy/client/node_modules/@babel/runtime/helpers/objectSpread2.js\").default;\nvar _asyncToGenerator = require(\"C:/Users/paete/Prototype/nftmusicProtoCopy/client/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\nvar _asyncIterator = require(\"C:/Users/paete/Prototype/nftmusicProtoCopy/client/node_modules/@babel/runtime/helpers/asyncIterator.js\").default;\nvar _require = require('uint8arrays/from-string'),\n  uint8ArrayFromString = _require.fromString;\nvar _require2 = require('uint8arrays/to-string'),\n  uint8ArrayToString = _require2.toString;\nvar log = require('debug')('ipfs-http-client:pubsub:subscribe');\nvar configure = require('../lib/configure');\nvar toUrlSearchParams = require('../lib/to-url-search-params');\n\n/**\n * @typedef {import('../types').HTTPClientExtraOptions} HTTPClientExtraOptions\n * @typedef {import('ipfs-core-types/src/pubsub').Message} Message\n * @typedef {(err: Error, fatal: boolean, msg?: Message) => void} ErrorHandlerFn\n * @typedef {import('ipfs-core-types/src/pubsub').API<HTTPClientExtraOptions & { onError?: ErrorHandlerFn }>} PubsubAPI\n * @typedef {import('../types').Options} Options\n */\n\n/**\n * @param {Options} options\n * @param {import('./subscription-tracker')} subsTracker\n */\nmodule.exports = function (options, subsTracker) {\n  return configure(function (api) {\n    /**\n     * @type {PubsubAPI[\"subscribe\"]}\n     */\n    function subscribe(_x, _x2) {\n      return _subscribe.apply(this, arguments);\n    }\n    function _subscribe() {\n      _subscribe = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(topic, handler) {\n        var options,\n          done,\n          fail,\n          result,\n          ffWorkaround,\n          _args = arguments;\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) switch (_context.prev = _context.next) {\n            case 0:\n              options = _args.length > 2 && _args[2] !== undefined ? _args[2] : {};\n              // eslint-disable-line require-await\n              options.signal = subsTracker.subscribe(topic, handler, options.signal);\n\n              /** @type {(value?: any) => void} */\n              result = new Promise(function (resolve, reject) {\n                done = resolve;\n                fail = reject;\n              }); // In Firefox, the initial call to fetch does not resolve until some data\n              // is received. If this doesn't happen within 1 second assume success\n              ffWorkaround = setTimeout(function () {\n                return done();\n              }, 1000); // Do this async to not block Firefox\n              api.post('pubsub/sub', {\n                signal: options.signal,\n                searchParams: toUrlSearchParams(_objectSpread({\n                  arg: topic\n                }, options)),\n                headers: options.headers\n              }).catch(function (err) {\n                // Initial subscribe fail, ensure we clean up\n                subsTracker.unsubscribe(topic, handler);\n                fail(err);\n              }).then(function (response) {\n                clearTimeout(ffWorkaround);\n                if (!response) {\n                  // if there was no response, the subscribe failed\n                  return;\n                }\n                readMessages(response, {\n                  onMessage: handler,\n                  onEnd: function onEnd() {\n                    return subsTracker.unsubscribe(topic, handler);\n                  },\n                  onError: options.onError\n                });\n                done();\n              });\n              return _context.abrupt(\"return\", result);\n            case 6:\n            case \"end\":\n              return _context.stop();\n          }\n        }, _callee);\n      }));\n      return _subscribe.apply(this, arguments);\n    }\n    return subscribe;\n  })(options);\n};\n\n/**\n * @param {import('ipfs-utils/src/types').ExtendedResponse} response\n * @param {object} options\n * @param {(message: Message) => void} options.onMessage\n * @param {() => void} options.onEnd\n * @param {ErrorHandlerFn} [options.onError]\n */\nfunction readMessages(_x3, _x4) {\n  return _readMessages.apply(this, arguments);\n}\n/**\n * @param {Error & {type?:string}} error\n * @returns {boolean}\n */\nfunction _readMessages() {\n  _readMessages = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(response, _ref) {\n    var onMessage, onEnd, onError, _iteratorAbruptCompletion, _didIteratorError, _iteratorError, _iterator, _step, msg;\n    return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n      while (1) switch (_context2.prev = _context2.next) {\n        case 0:\n          onMessage = _ref.onMessage, onEnd = _ref.onEnd, onError = _ref.onError;\n          onError = onError || log;\n          _context2.prev = 2;\n          _iteratorAbruptCompletion = false;\n          _didIteratorError = false;\n          _context2.prev = 5;\n          _iterator = _asyncIterator(response.ndjson());\n        case 7:\n          _context2.next = 9;\n          return _iterator.next();\n        case 9:\n          if (!(_iteratorAbruptCompletion = !(_step = _context2.sent).done)) {\n            _context2.next = 24;\n            break;\n          }\n          msg = _step.value;\n          _context2.prev = 11;\n          if (msg.from) {\n            _context2.next = 14;\n            break;\n          }\n          return _context2.abrupt(\"continue\", 21);\n        case 14:\n          onMessage({\n            from: uint8ArrayToString(uint8ArrayFromString(msg.from, 'base64pad'), 'base58btc'),\n            data: uint8ArrayFromString(msg.data, 'base64pad'),\n            seqno: uint8ArrayFromString(msg.seqno, 'base64pad'),\n            topicIDs: msg.topicIDs\n          });\n          _context2.next = 21;\n          break;\n        case 17:\n          _context2.prev = 17;\n          _context2.t0 = _context2[\"catch\"](11);\n          _context2.t0.message = \"Failed to parse pubsub message: \".concat(_context2.t0.message);\n          onError(_context2.t0, false, msg); // Not fatal\n        case 21:\n          _iteratorAbruptCompletion = false;\n          _context2.next = 7;\n          break;\n        case 24:\n          _context2.next = 30;\n          break;\n        case 26:\n          _context2.prev = 26;\n          _context2.t1 = _context2[\"catch\"](5);\n          _didIteratorError = true;\n          _iteratorError = _context2.t1;\n        case 30:\n          _context2.prev = 30;\n          _context2.prev = 31;\n          if (!(_iteratorAbruptCompletion && _iterator.return != null)) {\n            _context2.next = 35;\n            break;\n          }\n          _context2.next = 35;\n          return _iterator.return();\n        case 35:\n          _context2.prev = 35;\n          if (!_didIteratorError) {\n            _context2.next = 38;\n            break;\n          }\n          throw _iteratorError;\n        case 38:\n          return _context2.finish(35);\n        case 39:\n          return _context2.finish(30);\n        case 40:\n          _context2.next = 45;\n          break;\n        case 42:\n          _context2.prev = 42;\n          _context2.t2 = _context2[\"catch\"](2);\n          if (!isAbortError(_context2.t2)) {\n            onError(_context2.t2, true); // Fatal\n          }\n        case 45:\n          _context2.prev = 45;\n          onEnd();\n          return _context2.finish(45);\n        case 48:\n        case \"end\":\n          return _context2.stop();\n      }\n    }, _callee2, null, [[2, 42, 45, 48], [5, 26, 30, 40], [11, 17], [31,, 35, 39]]);\n  }));\n  return _readMessages.apply(this, arguments);\n}\nvar isAbortError = function isAbortError(error) {\n  switch (error.type) {\n    case 'aborted':\n      return true;\n    // It is `abort` in Electron instead of `aborted`\n    case 'abort':\n      return true;\n    default:\n      // FIXME: In testing with Chrome, err.type is undefined (should not be!)\n      // Temporarily use the name property instead.\n      return error.name === 'AbortError';\n  }\n};","map":{"version":3,"names":["require","uint8ArrayFromString","fromString","uint8ArrayToString","toString","log","configure","toUrlSearchParams","module","exports","options","subsTracker","api","subscribe","topic","handler","signal","result","Promise","resolve","reject","done","fail","ffWorkaround","setTimeout","post","searchParams","arg","headers","catch","err","unsubscribe","then","response","clearTimeout","readMessages","onMessage","onEnd","onError","ndjson","msg","from","data","seqno","topicIDs","message","isAbortError","error","type","name"],"sources":["C:/Users/paete/Prototype/nftmusicProtoCopy/client/node_modules/ipfs-http-client/src/pubsub/subscribe.js"],"sourcesContent":["'use strict'\n\nconst { fromString: uint8ArrayFromString } = require('uint8arrays/from-string')\nconst { toString: uint8ArrayToString } = require('uint8arrays/to-string')\nconst log = require('debug')('ipfs-http-client:pubsub:subscribe')\nconst configure = require('../lib/configure')\nconst toUrlSearchParams = require('../lib/to-url-search-params')\n\n/**\n * @typedef {import('../types').HTTPClientExtraOptions} HTTPClientExtraOptions\n * @typedef {import('ipfs-core-types/src/pubsub').Message} Message\n * @typedef {(err: Error, fatal: boolean, msg?: Message) => void} ErrorHandlerFn\n * @typedef {import('ipfs-core-types/src/pubsub').API<HTTPClientExtraOptions & { onError?: ErrorHandlerFn }>} PubsubAPI\n * @typedef {import('../types').Options} Options\n */\n\n/**\n * @param {Options} options\n * @param {import('./subscription-tracker')} subsTracker\n */\nmodule.exports = (options, subsTracker) => {\n  return configure((api) => {\n    /**\n     * @type {PubsubAPI[\"subscribe\"]}\n     */\n    async function subscribe (topic, handler, options = {}) { // eslint-disable-line require-await\n      options.signal = subsTracker.subscribe(topic, handler, options.signal)\n\n      /** @type {(value?: any) => void} */\n      let done\n      /** @type {(error: Error) => void} */\n      let fail\n\n      const result = new Promise((resolve, reject) => {\n        done = resolve\n        fail = reject\n      })\n\n      // In Firefox, the initial call to fetch does not resolve until some data\n      // is received. If this doesn't happen within 1 second assume success\n      const ffWorkaround = setTimeout(() => done(), 1000)\n\n      // Do this async to not block Firefox\n      api.post('pubsub/sub', {\n        signal: options.signal,\n        searchParams: toUrlSearchParams({\n          arg: topic,\n          ...options\n        }),\n        headers: options.headers\n      })\n        .catch((err) => {\n          // Initial subscribe fail, ensure we clean up\n          subsTracker.unsubscribe(topic, handler)\n\n          fail(err)\n        })\n        .then((response) => {\n          clearTimeout(ffWorkaround)\n\n          if (!response) {\n            // if there was no response, the subscribe failed\n            return\n          }\n\n          readMessages(response, {\n            onMessage: handler,\n            onEnd: () => subsTracker.unsubscribe(topic, handler),\n            onError: options.onError\n          })\n\n          done()\n        })\n\n      return result\n    }\n    return subscribe\n  })(options)\n}\n\n/**\n * @param {import('ipfs-utils/src/types').ExtendedResponse} response\n * @param {object} options\n * @param {(message: Message) => void} options.onMessage\n * @param {() => void} options.onEnd\n * @param {ErrorHandlerFn} [options.onError]\n */\nasync function readMessages (response, { onMessage, onEnd, onError }) {\n  onError = onError || log\n\n  try {\n    for await (const msg of response.ndjson()) {\n      try {\n        if (!msg.from) {\n          continue\n        }\n\n        onMessage({\n          from: uint8ArrayToString(uint8ArrayFromString(msg.from, 'base64pad'), 'base58btc'),\n          data: uint8ArrayFromString(msg.data, 'base64pad'),\n          seqno: uint8ArrayFromString(msg.seqno, 'base64pad'),\n          topicIDs: msg.topicIDs\n        })\n      } catch (err) {\n        err.message = `Failed to parse pubsub message: ${err.message}`\n        onError(err, false, msg) // Not fatal\n      }\n    }\n  } catch (err) {\n    if (!isAbortError(err)) {\n      onError(err, true) // Fatal\n    }\n  } finally {\n    onEnd()\n  }\n}\n\n/**\n * @param {Error & {type?:string}} error\n * @returns {boolean}\n */\nconst isAbortError = error => {\n  switch (error.type) {\n    case 'aborted':\n      return true\n    // It is `abort` in Electron instead of `aborted`\n    case 'abort':\n      return true\n    default:\n      // FIXME: In testing with Chrome, err.type is undefined (should not be!)\n      // Temporarily use the name property instead.\n      return error.name === 'AbortError'\n  }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}