{"ast":null,"code":"'use strict';\n\nvar _regeneratorRuntime = require(\"C:/Users/paete/Prototype/nftmusicProtoCopy/client/node_modules/@babel/runtime/helpers/regeneratorRuntime.js\").default;\nvar _objectSpread = require(\"C:/Users/paete/Prototype/nftmusicProtoCopy/client/node_modules/@babel/runtime/helpers/objectSpread2.js\").default;\nvar _asyncToGenerator = require(\"C:/Users/paete/Prototype/nftmusicProtoCopy/client/node_modules/@babel/runtime/helpers/asyncToGenerator.js\").default;\nvar _asyncIterator = require(\"C:/Users/paete/Prototype/nftmusicProtoCopy/client/node_modules/@babel/runtime/helpers/asyncIterator.js\").default;\nvar _require = require('multiaddr'),\n  Multiaddr = _require.Multiaddr;\nvar configure = require('../lib/configure');\nvar toUrlSearchParams = require('../lib/to-url-search-params');\nvar _require2 = require('./response-types'),\n  FinalPeer = _require2.FinalPeer;\n\n/**\n * @typedef {import('../types').HTTPClientExtraOptions} HTTPClientExtraOptions\n * @typedef {import('ipfs-core-types/src/dht').API<HTTPClientExtraOptions>} DHTAPI\n */\n\nmodule.exports = configure(function (api) {\n  /**\n   * @type {DHTAPI[\"findPeer\"]}\n   */\n  function findPeer(_x) {\n    return _findPeer.apply(this, arguments);\n  }\n  function _findPeer() {\n    _findPeer = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(peerId) {\n      var options,\n        res,\n        _iteratorAbruptCompletion,\n        _didIteratorError,\n        _iteratorError,\n        _iterator,\n        _step,\n        data,\n        _data$Responses$,\n        ID,\n        Addrs,\n        _args = arguments;\n      return _regeneratorRuntime().wrap(function _callee$(_context) {\n        while (1) switch (_context.prev = _context.next) {\n          case 0:\n            options = _args.length > 1 && _args[1] !== undefined ? _args[1] : {};\n            _context.next = 3;\n            return api.post('dht/findpeer', {\n              signal: options.signal,\n              searchParams: toUrlSearchParams(_objectSpread({\n                arg: peerId\n              }, options)),\n              headers: options.headers\n            });\n          case 3:\n            res = _context.sent;\n            _iteratorAbruptCompletion = false;\n            _didIteratorError = false;\n            _context.prev = 6;\n            _iterator = _asyncIterator(res.ndjson());\n          case 8:\n            _context.next = 10;\n            return _iterator.next();\n          case 10:\n            if (!(_iteratorAbruptCompletion = !(_step = _context.sent).done)) {\n              _context.next = 18;\n              break;\n            }\n            data = _step.value;\n            if (!(data.Type === FinalPeer && data.Responses)) {\n              _context.next = 15;\n              break;\n            }\n            _data$Responses$ = data.Responses[0], ID = _data$Responses$.ID, Addrs = _data$Responses$.Addrs;\n            return _context.abrupt(\"return\", {\n              id: ID,\n              addrs: (Addrs || []).map(function ( /** @type {string} **/a) {\n                return new Multiaddr(a);\n              })\n            });\n          case 15:\n            _iteratorAbruptCompletion = false;\n            _context.next = 8;\n            break;\n          case 18:\n            _context.next = 24;\n            break;\n          case 20:\n            _context.prev = 20;\n            _context.t0 = _context[\"catch\"](6);\n            _didIteratorError = true;\n            _iteratorError = _context.t0;\n          case 24:\n            _context.prev = 24;\n            _context.prev = 25;\n            if (!(_iteratorAbruptCompletion && _iterator.return != null)) {\n              _context.next = 29;\n              break;\n            }\n            _context.next = 29;\n            return _iterator.return();\n          case 29:\n            _context.prev = 29;\n            if (!_didIteratorError) {\n              _context.next = 32;\n              break;\n            }\n            throw _iteratorError;\n          case 32:\n            return _context.finish(29);\n          case 33:\n            return _context.finish(24);\n          case 34:\n            throw new Error('not found');\n          case 35:\n          case \"end\":\n            return _context.stop();\n        }\n      }, _callee, null, [[6, 20, 24, 34], [25,, 29, 33]]);\n    }));\n    return _findPeer.apply(this, arguments);\n  }\n  return findPeer;\n});","map":{"version":3,"names":["require","Multiaddr","configure","toUrlSearchParams","FinalPeer","module","exports","api","findPeer","peerId","options","post","signal","searchParams","arg","headers","res","ndjson","data","Type","Responses","ID","Addrs","id","addrs","map","a","Error"],"sources":["C:/Users/paete/Prototype/nftmusicProtoCopy/client/node_modules/ipfs-http-client/src/dht/find-peer.js"],"sourcesContent":["'use strict'\n\nconst { Multiaddr } = require('multiaddr')\nconst configure = require('../lib/configure')\nconst toUrlSearchParams = require('../lib/to-url-search-params')\nconst { FinalPeer } = require('./response-types')\n\n/**\n * @typedef {import('../types').HTTPClientExtraOptions} HTTPClientExtraOptions\n * @typedef {import('ipfs-core-types/src/dht').API<HTTPClientExtraOptions>} DHTAPI\n */\n\nmodule.exports = configure(api => {\n  /**\n   * @type {DHTAPI[\"findPeer\"]}\n   */\n  async function findPeer (peerId, options = {}) {\n    const res = await api.post('dht/findpeer', {\n      signal: options.signal,\n      searchParams: toUrlSearchParams({\n        arg: peerId,\n        ...options\n      }),\n      headers: options.headers\n    })\n\n    for await (const data of res.ndjson()) {\n      if (data.Type === FinalPeer && data.Responses) {\n        const { ID, Addrs } = data.Responses[0]\n        return {\n          id: ID,\n          addrs: (Addrs || []).map((/** @type {string} **/ a) => new Multiaddr(a))\n        }\n      }\n    }\n\n    throw new Error('not found')\n  }\n\n  return findPeer\n})\n"],"mappings":"AAAA,YAAY;;AAAA;AAAA;AAAA;AAAA;AAEZ,eAAsBA,OAAO,CAAC,WAAW,CAAC;EAAlCC,SAAS,YAATA,SAAS;AACjB,IAAMC,SAAS,GAAGF,OAAO,CAAC,kBAAkB,CAAC;AAC7C,IAAMG,iBAAiB,GAAGH,OAAO,CAAC,6BAA6B,CAAC;AAChE,gBAAsBA,OAAO,CAAC,kBAAkB,CAAC;EAAzCI,SAAS,aAATA,SAAS;;AAEjB;AACA;AACA;AACA;;AAEAC,MAAM,CAACC,OAAO,GAAGJ,SAAS,CAAC,UAAAK,GAAG,EAAI;EAChC;AACF;AACA;EAFE,SAGeC,QAAQ;IAAA;EAAA;EAAA;IAAA,uEAAvB,iBAAyBC,MAAM;MAAA;QAAA;QAAA;QAAA;QAAA;QAAA;QAAA;QAAA;QAAA;QAAA;QAAA;QAAA;MAAA;QAAA;UAAA;YAAEC,OAAO,2DAAG,CAAC,CAAC;YAAA;YAAA,OACzBH,GAAG,CAACI,IAAI,CAAC,cAAc,EAAE;cACzCC,MAAM,EAAEF,OAAO,CAACE,MAAM;cACtBC,YAAY,EAAEV,iBAAiB;gBAC7BW,GAAG,EAAEL;cAAM,GACRC,OAAO,EACV;cACFK,OAAO,EAAEL,OAAO,CAACK;YACnB,CAAC,CAAC;UAAA;YAPIC,GAAG;YAAA;YAAA;YAAA;YAAA,2BASgBA,GAAG,CAACC,MAAM,EAAE;UAAA;YAAA;YAAA;UAAA;YAAA;cAAA;cAAA;YAAA;YAApBC,IAAI;YAAA,MACfA,IAAI,CAACC,IAAI,KAAKf,SAAS,IAAIc,IAAI,CAACE,SAAS;cAAA;cAAA;YAAA;YAAA,mBACrBF,IAAI,CAACE,SAAS,CAAC,CAAC,CAAC,EAA/BC,EAAE,oBAAFA,EAAE,EAAEC,KAAK,oBAALA,KAAK;YAAA,iCACV;cACLC,EAAE,EAAEF,EAAE;cACNG,KAAK,EAAE,CAACF,KAAK,IAAI,EAAE,EAAEG,GAAG,CAAC,WAAC,sBAAuBC,CAAC;gBAAA,OAAK,IAAIzB,SAAS,CAACyB,CAAC,CAAC;cAAA;YACzE,CAAC;UAAA;YAAA;YAAA;YAAA;UAAA;YAAA;YAAA;UAAA;YAAA;YAAA;YAAA;YAAA;UAAA;YAAA;YAAA;YAAA;cAAA;cAAA;YAAA;YAAA;YAAA;UAAA;YAAA;YAAA;cAAA;cAAA;YAAA;YAAA;UAAA;YAAA;UAAA;YAAA;UAAA;YAAA,MAIC,IAAIC,KAAK,CAAC,WAAW,CAAC;UAAA;UAAA;YAAA;QAAA;MAAA;IAAA,CAC7B;IAAA;EAAA;EAED,OAAOnB,QAAQ;AACjB,CAAC,CAAC"},"metadata":{},"sourceType":"script","externalDependencies":[]}