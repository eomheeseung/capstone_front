{"ast":null,"code":"\"use strict\";\n\n// Copyright (C) 2016 Dmitry Chestnykh\n// MIT License. See LICENSE file for details.\nvar _classCallCheck = require(\"C:/Users/paete/Prototype/nftmusicProtoCopy/client/node_modules/@babel/runtime/helpers/classCallCheck.js\").default;\nvar _createClass = require(\"C:/Users/paete/Prototype/nftmusicProtoCopy/client/node_modules/@babel/runtime/helpers/createClass.js\").default;\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.NodeRandomSource = void 0;\nvar wipe_1 = require(\"@stablelib/wipe\");\nvar NodeRandomSource = /*#__PURE__*/function () {\n  function NodeRandomSource() {\n    _classCallCheck(this, NodeRandomSource);\n    this.isAvailable = false;\n    this.isInstantiated = false;\n    if (typeof require !== \"undefined\") {\n      var nodeCrypto = require(\"crypto\");\n      if (nodeCrypto && nodeCrypto.randomBytes) {\n        this._crypto = nodeCrypto;\n        this.isAvailable = true;\n        this.isInstantiated = true;\n      }\n    }\n  }\n  _createClass(NodeRandomSource, [{\n    key: \"randomBytes\",\n    value: function randomBytes(length) {\n      if (!this.isAvailable || !this._crypto) {\n        throw new Error(\"Node.js random byte generator is not available.\");\n      }\n      // Get random bytes (result is Buffer).\n      var buffer = this._crypto.randomBytes(length);\n      // Make sure we got the length that we requested.\n      if (buffer.length !== length) {\n        throw new Error(\"NodeRandomSource: got fewer bytes than requested\");\n      }\n      // Allocate output array.\n      var out = new Uint8Array(length);\n      // Copy bytes from buffer to output.\n      for (var i = 0; i < out.length; i++) {\n        out[i] = buffer[i];\n      }\n      // Cleanup.\n      (0, wipe_1.wipe)(buffer);\n      return out;\n    }\n  }]);\n  return NodeRandomSource;\n}();\nexports.NodeRandomSource = NodeRandomSource;","map":{"version":3,"mappings":";;AAAA;AACA;AAAA;AAAA;;;;;AAGA;AAAuC,IAI1BA,gBAAgB;EAMzB;IAAA;IALA,gBAAW,GAAG,KAAK;IACnB,mBAAc,GAAG,KAAK;IAKlB,IAAI,OAAOC,OAAO,KAAK,WAAW,EAAE;MAChC,IAAMC,UAAU,GAAGD,OAAO,CAAC,QAAQ,CAAC;MACpC,IAAIC,UAAU,IAAIA,UAAU,CAACC,WAAW,EAAE;QACtC,IAAI,CAACC,OAAO,GAAGF,UAAU;QACzB,IAAI,CAACG,WAAW,GAAG,IAAI;QACvB,IAAI,CAACC,cAAc,GAAG,IAAI;;;EAGtC;EAAC;IAAA;IAAA,OAED,qBAAYC,MAAc;MACtB,IAAI,CAAC,IAAI,CAACF,WAAW,IAAI,CAAC,IAAI,CAACD,OAAO,EAAE;QACpC,MAAM,IAAII,KAAK,CAAC,iDAAiD,CAAC;;MAGtE;MACA,IAAIC,MAAM,GAAG,IAAI,CAACL,OAAO,CAACD,WAAW,CAACI,MAAM,CAAC;MAE7C;MACA,IAAIE,MAAM,CAACF,MAAM,KAAKA,MAAM,EAAE;QAC1B,MAAM,IAAIC,KAAK,CAAC,kDAAkD,CAAC;;MAGvE;MACA,IAAME,GAAG,GAAG,IAAIC,UAAU,CAACJ,MAAM,CAAC;MAElC;MACA,KAAK,IAAIK,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGF,GAAG,CAACH,MAAM,EAAEK,CAAC,EAAE,EAAE;QACjCF,GAAG,CAACE,CAAC,CAAC,GAAGH,MAAM,CAACG,CAAC,CAAC;;MAGtB;MACA,eAAI,EAACH,MAAM,CAAC;MAEZ,OAAOC,GAAG;IACd;EAAC;EAAA;AAAA;AA1CLG","names":["NodeRandomSource","require","nodeCrypto","randomBytes","_crypto","isAvailable","isInstantiated","length","Error","buffer","out","Uint8Array","i","exports"],"sources":["C:\\Users\\paete\\Prototype\\nftmusicProtoCopy\\client\\node_modules\\@stablelib\\random\\source\\node.ts"],"sourcesContent":["// Copyright (C) 2016 Dmitry Chestnykh\n// MIT License. See LICENSE file for details.\n\nimport { RandomSource } from \"./\";\nimport { wipe } from \"@stablelib/wipe\";\n\ndeclare function require(name: string): any;\n\nexport class NodeRandomSource implements RandomSource {\n    isAvailable = false;\n    isInstantiated = false;\n\n    private _crypto: { randomBytes(n: number): Uint8Array } | undefined;\n\n    constructor() {\n        if (typeof require !== \"undefined\") {\n            const nodeCrypto = require(\"crypto\");\n            if (nodeCrypto && nodeCrypto.randomBytes) {\n                this._crypto = nodeCrypto;\n                this.isAvailable = true;\n                this.isInstantiated = true;\n            }\n        }\n    }\n\n    randomBytes(length: number): Uint8Array {\n        if (!this.isAvailable || !this._crypto) {\n            throw new Error(\"Node.js random byte generator is not available.\");\n        }\n\n        // Get random bytes (result is Buffer).\n        let buffer = this._crypto.randomBytes(length);\n\n        // Make sure we got the length that we requested.\n        if (buffer.length !== length) {\n            throw new Error(\"NodeRandomSource: got fewer bytes than requested\");\n        }\n\n        // Allocate output array.\n        const out = new Uint8Array(length);\n\n        // Copy bytes from buffer to output.\n        for (let i = 0; i < out.length; i++) {\n            out[i] = buffer[i];\n        }\n\n        // Cleanup.\n        wipe(buffer);\n\n        return out;\n    }\n}\n"]},"metadata":{},"sourceType":"script","externalDependencies":[]}